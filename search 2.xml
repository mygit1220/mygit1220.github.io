<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>IELTS计划</title>
      <link href="/2021/08/27/IELTS%E8%AE%A1%E5%88%92/"/>
      <url>/2021/08/27/IELTS%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p>某天，突然觉得自己太废材了，下班时间基本上就是刷短视频度过的，这样一天天下来，越来越空虚。。。很久以前想要学一门语言的念头就又蹦了出来，想学的语言主要集中在韩语、粤语、日语、英语上，考虑到自己的时间以及能力，就打算在韩语和英语中选一门。之前上学的时候，因为韩剧学过一段时间的韩语，基本上也就是能念不认识的阶段，英语呢也算是断断续续学了这么多年，也一直处于哑巴状态。在使用及实用的综合考量下还是决定学英语，网上冲浪一番之后就有了考雅思的决定。接下来的就是知乎上找各种牛人的学习经验以及计划安排，各种翻找之下找到了一篇适合自己节奏的文章，本文的计划就是基于该文章排下来的。</p><H3> 前期准备工作--找资料 </H3><ul><li>纸质资料<ul><li>剑桥真题</li></ul></li><li>音频<ul><li>BBC新闻</li><li>Mini口语</li><li>Simon写作</li></ul></li><li>App<ul><li>雅思哥</li><li>考满分词汇-雅思</li><li>雅思考满分</li><li>小站雅思</li></ul></li></ul><H3> 计划 </H3><ul><li>第一个月</li></ul><table><thead><tr><th>排期</th><th>✅词汇</th><th>✅听力</th><th>✅阅读</th><th>✅口语</th><th>✅写作</th></tr></thead><tbody><tr><td>周一</td><td>上下班的路上跟着考满分词汇-雅思APP节奏学习词汇</td><td>睡前听BBC20分钟左右，顺带看1-2条BBC新闻,剑桥6-9的听力题</td><td>抽时间听阅读课</td><td>找Oliver的口语Mini课，学逻辑思路，抽时间跟着雅思哥、雅思考满分APP听练</td><td>听simon的写作课，看优秀写作</td></tr><tr><td>周二</td><td>上下班的路上跟着考满分词汇-雅思APP节奏学习词汇</td><td>睡前听BBC20分钟左右，顺带看1-2条BBC新闻</td><td>抽时间听阅读课</td><td>找Oliver的口语Mini课，学逻辑思路，抽时间跟着雅思哥、雅思考满分APP听练</td><td>听simon的写作课，看优秀写作</td></tr><tr><td>周三</td><td>上下班的路上跟着考满分词汇-雅思APP节奏学习词汇</td><td>睡前听BBC20分钟左右，顺带看1-2条BBC新闻,剑桥6-9的听力题</td><td>抽时间听阅读课</td><td>找Oliver的口语Mini课，学逻辑思路，抽时间跟着雅思哥、雅思考满分APP听练</td><td>听simon的写作课，看优秀写作</td></tr><tr><td>周四</td><td>上下班的路上跟着考满分词汇-雅思APP节奏学习词汇</td><td>睡前听BBC20分钟左右，顺带看1-2条BBC新闻</td><td>抽时间听阅读课</td><td>找Oliver的口语Mini课，学逻辑思路，抽时间跟着雅思哥、雅思考满分APP听练</td><td>听simon的写作课，看优秀写作</td></tr><tr><td>周五</td><td>上下班的路上跟着考满分词汇-雅思APP节奏学习词汇</td><td>睡前听BBC20分钟左右，顺带看1-2条BBC新闻</td><td>抽时间听阅读课</td><td>找Oliver的口语Mini课，学逻辑思路，抽时间跟着雅思哥、雅思考满分APP听练</td><td>听simon的写作课，看优秀写作</td></tr><tr><td>周六</td><td>跟着考满分词汇-雅思APP节奏学习词汇</td><td>睡前听BBC20分钟左右，顺带看1-2条BBC新闻,剑桥6-9的听力题</td><td>做剑桥6-9的阅读题</td><td>找个英语电影看放松放松</td><td>听simon的写作课，，看优秀写作，总结常用表达</td></tr><tr><td>周日</td><td>跟着考满分词汇-雅思APP节奏学习词汇</td><td>睡前听BBC20分钟左右，顺带看1-2条BBC新闻,语料库周末会听3-4 Lists</td><td>做剑桥6-9的阅读题</td><td>找Oliver的口语Mini课，学逻辑思路，跟着雅思哥、雅思考满分APP听练</td><td>听simon的写作课，看优秀写作，总结常用表达</td></tr></tbody></table><p>✅词汇：每天坚持跟着考满分词汇-雅思APP的节奏学习基础、核心、高频词汇。<br>✅听力：有时间就听听BBC新闻，听不懂没关系，主要就是为了找回英语的感觉。第一个月保证一周做一套剑桥6-9的听力题，周末听语料库3-4 Lists。<br>✅阅读：找阅读课听，掌握基本的思路和技巧，保证一周做完一套剑桥6-9的阅读题。<br>✅口语：听Oliver的口语Mini课，学逻辑思路。然后跟着雅思哥APP、雅思考满分APP里面按照不同分类排放的口语题目练习。<br>✅写作：听simon的写作课，总结剑桥4-14中考官范文的套路，常用表达（比如一些表示增减的词语，总结句等），然后背诵常见的题型和经典的题目中范文。找写作书资料，做详细的笔记，然后复习。</p><ul><li>第二个月</li></ul><table><thead><tr><th>排期</th><th>✅词汇</th><th>✅听力</th><th>✅阅读</th><th>✅口语</th><th>✅写作</th></tr></thead><tbody><tr><td>周一</td><td>上下班的路上跟着考满分词汇-雅思APP节奏学习词汇</td><td>睡前听BBC20分钟左右，顺带看1-2条BBC新闻，听Oliver的听力课</td><td>做1篇阅读</td><td>找Oliver的口语Mini课，学逻辑思路，抽时间跟着雅思哥、雅思考满分APP听练，朗读 BBC 6 min English的内容</td><td>听simon的写作课，看优秀写作</td></tr><tr><td>周二</td><td>上下班的路上跟着考满分词汇-雅思APP节奏学习词汇</td><td>睡前听BBC20分钟左右，顺带看1-2条BBC新闻，听Oliver的听力课</td><td>做1篇阅读</td><td>找Oliver的口语Mini课，学逻辑思路，抽时间跟着雅思哥、雅思考满分APP听练，朗读 BBC 6 min English的内容</td><td>听simon的写作课，看优秀写作</td></tr><tr><td>周三</td><td>上下班的路上跟着考满分词汇-雅思APP节奏学习词汇</td><td>睡前听BBC20分钟左右，顺带看1-2条BBC新闻，听Oliver的听力课</td><td>做1篇阅读</td><td>找Oliver的口语Mini课，学逻辑思路，抽时间跟着雅思哥、雅思考满分APP听练，朗读 BBC 6 min English的内容</td><td>听simon的写作课，看优秀写作</td></tr><tr><td>周四</td><td>上下班的路上跟着考满分词汇-雅思APP节奏学习词汇</td><td>睡前听BBC20分钟左右，顺带看1-2条BBC新闻，听Oliver的听力课</td><td>做1篇阅读</td><td>找Oliver的口语Mini课，学逻辑思路，抽时间跟着雅思哥、雅思考满分APP听练，朗读 BBC 6 min English的内容</td><td>听simon的写作课，看优秀写作</td></tr><tr><td>周五</td><td>上下班的路上跟着考满分词汇-雅思APP节奏学习词汇</td><td>睡前听BBC20分钟左右，顺带看1-2条BBC新闻，听Oliver的听力课</td><td>做1篇阅读</td><td>找Oliver的口语Mini课，学逻辑思路，抽时间跟着雅思哥、雅思考满分APP听练，朗读 BBC 6 min English的内容</td><td>听simon的写作课，看优秀写作</td></tr><tr><td>周六</td><td>跟着考满分词汇-雅思APP节奏学习词汇</td><td>睡前听BBC20分钟左右，顺带看1-2条BBC新闻，做一套听力题</td><td>做1篇阅读</td><td>找个英语电影看放松放松，朗读 BBC 6 min English的内容</td><td>听simon的写作课，，看优秀写作，总结常用表达，开始写小作文、大作文</td></tr><tr><td>周日</td><td>跟着考满分词汇-雅思APP节奏学习词汇</td><td>睡前听BBC20分钟左右，顺带看1-2条BBC新闻,做一套听力题</td><td>做1篇阅读</td><td>朗读 BBC 6 min English的内容，准备常考的6大类话题朗读</td><td>听simon的写作课，看优秀写作，总结常用表达，开始写小作文、大作文</td></tr></tbody></table><p>✅词汇：继续每天坚持跟着考满分词汇-雅思APP的节奏学习基础、核心、高频词汇。<br>✅听力：前三周，平均一周一套听力。严格按照Oliver课里的指导练习，结合听力技巧和仔细的错题分析，复习。<br>✅阅读：平均每天做1篇阅读，做一篇对一次答案，总结错题，每篇卡时间20分钟。自己找题目做。<br>✅口语：每天找类似BBC 6 min English的内容，朗读，找对话的语感。准备常考的6大类话题，每天准备一类。结合自己的故事，想内容，写下来，朗读，修改。找类似英文素材，朗读。<br>✅作文：大作文把四种类型的作文框架都搭好，开始写小作文、大作文。</p><p>先按着这个节奏来实行吧，遇到问题再行调整！</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
          <category> 计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IELTS(雅思) </tag>
            
            <tag> 计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在gitlab上复制一个新项目</title>
      <link href="/2021/08/19/%E5%9C%A8gitlab%E4%B8%8A%E5%A4%8D%E5%88%B6%E4%B8%80%E4%B8%AA%E6%96%B0%E9%A1%B9%E7%9B%AE/"/>
      <url>/2021/08/19/%E5%9C%A8gitlab%E4%B8%8A%E5%A4%8D%E5%88%B6%E4%B8%80%E4%B8%AA%E6%96%B0%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<ul><li><p>git clone <a href="https://gitlab.xxx.tech/fmfe/xxx/xxx.git">https://gitlab.xxx.tech/fmfe/xxx/xxx.git</a> (要复制的项目仓库地址)</p></li><li><p>git remote -v (查看一下现在的远程地址)</p></li><li><p>git remote set-url origin <a href="mailto:&#103;&#105;&#116;&#x40;&#x67;&#x69;&#116;&#108;&#x61;&#x62;&#x2e;&#x78;&#120;&#120;&#46;&#116;&#101;&#x63;&#x68;">&#103;&#105;&#116;&#x40;&#x67;&#x69;&#116;&#108;&#x61;&#x62;&#x2e;&#x78;&#120;&#120;&#46;&#116;&#101;&#x63;&#x68;</a>/fmfe/xxx/xxx.git (你需要的项目仓库地址，地址自己取一个，只要保证是空仓库就可以)</p></li><li><p>git push -u origin (push到远程)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端基础知识 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工程化 </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20210811胡说八道</title>
      <link href="/2021/08/11/%E5%BF%83%E6%83%85%E5%B0%8F%E8%AE%B0/"/>
      <url>/2021/08/11/%E5%BF%83%E6%83%85%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>最近又重温了《父母爱情》这部电视剧，事实上18年的时候就看过了，但是最近在某短视频平台上看到了一个片段，又动了看一看它的心思，这一看就看完了全集。看完全集之后还不过瘾，又跑去看完了原著小说，看完原著小说之后，心里说不出的难过 — 电视剧升华了原著。原著更真实地反应了人性，电视剧中把这些场景美化了，其中一处便是江昌义认爹的剧情。</p><p>电视剧中江昌义认爹的情形跟原著中一样，不同的在于各个相关人物的心理历程以及表现。剧中的江昌义是自己为了前途跑来认爹，事后到了部队上也积极向上，成长为了军队的栋梁，最终也说出了事情的真相，虽然整个人自私了一点，但是也得到了大家的原谅。剧中的江昌义母亲张桂兰是完全不支持他认爹的行为的，是江昌义自己偷偷跑来的，塑造了一个悲凉的农村妇女的形象。剧中的江德福从江昌义进门的瞬间就知道他不是自己的儿子，但是为了江家的脸面还是认下了这个儿子，至于为什么一进门就知道不是自己的儿子，原因在于他自己根本没碰张桂兰，树立了一个高大伟岸的光辉形象。然而原著中这三个人却是截然不同的表现。首先，江昌义不是自己要来认爹的，是张桂兰临死的时候告诉他这些事情，让他装作是江德福的儿子来认爹，跟剧中一样他如愿当兵了，但是最终并没有像剧中那样成为一名军人，而是成为了一家集团的董事长兼总经理。同时跟剧中不一样的是事情的真相是在多年以后作者在出差的时候去拜访她的大哥江昌义的时候，才被江昌义义正言辞地说出来。其次，在江昌义讲述的真相中他之所以去认爹，是张桂兰临死的时候指使的。张桂兰在明知道江昌义的亲爹–江德福的大哥还活着的情况下，依然让江昌义去认江德福为爹，去破坏江德福的家庭，可见其内心的愤恨。最后，在江昌义来认爹的时候，江德福也不像剧中的那样笃定他不是自己的儿子。在看到酷似自己面容的江昌义时，江德福怀疑了，在这种疑心之下他认下了江昌义。剧中把这些人物进行了二次创作来达到影视剧人物的播放效果，编辑和导演的功底着实厉害！</p><p>原著中的江昌义是仇视安杰的，因为他认为是安杰这个城市女人抢走了属于他妈张桂兰这个农村女人的幸福生活。在他看来即使是张桂兰安守妇道，为江德福守身如玉也免不了被抛弃的命运，因为江德福不会带一个裹着小脚的农村女人进城当军官太太。原著中江德福到底会不会带张桂兰进城并没有一个定论，但是电视剧中隐晦地说明了这点，比如，老丁媳妇王秀蛾的难产而死，老丁一直想要找个文化人续弦；再比如王海洋他妈生病去世，王海洋他爸也找了葛老师这个文化人续弦，我觉得编剧已经给出了答案。</p><p>就男人成功了会不会或者说该不该抛弃糟糠之妻这个问题，以下是我的胡说八道。当男人成功之后见的东西多了，诱惑也多了，当物质已经达到了极致的满足，就会追求精神上的满足，这时便觉得糟糠之妻不再是自己的良配，外面会有更年轻漂亮的知书达理的等着自己，这是人性。我并不反对两个人分开，因为每个人都有追求自己幸福的权利，不能道德绑架说富豪一定不能离婚，但是一定要给陪伴了自己多年的这个伴侣足够多的经济补偿，因为这是作为人的良知，反观有些人甚至为了这些补偿要送对方去坐牢，简直是在玷污那一撇一捺！</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
            <tag> 感想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20个必会的JavaScript面试题</title>
      <link href="/2021/08/06/20%E4%B8%AA%E5%BF%85%E4%BC%9A%E7%9A%84JavaScript%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2021/08/06/20%E4%B8%AA%E5%BF%85%E4%BC%9A%E7%9A%84JavaScript%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<H3> JavaScript 中 undefined 和 not defined 的区别 </H3><p>JavaScript 未声明变量直接使用会抛出异常：var name is not defined，如果没有处理异常，代码就停止运行了。 但是，使用typeof undeclared_variable并不会产生异常，会直接返回 undefined。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var x; // 声明 x</span><br><span class="line">console.log(x); // undefined</span><br><span class="line">console.log(typeof y); // undefined</span><br><span class="line">console.log(z);  // 抛出异常: ReferenceError: z is not defined</span><br></pre></td></tr></table></figure><H3> 以下代码输出什么 </H3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var y = 1;</span><br><span class="line">if (function f()&#123;&#125;) &#123;</span><br><span class="line">    y += typeof f;</span><br><span class="line">&#125;</span><br><span class="line">console.log(y);</span><br></pre></td></tr></table></figure><ul><li><code>JavaScript</code>中<code>if</code>语句求值其实使用<code>eval</code>函数，该方法(<code>eval()</code>)只接受原始字符串作为参数，如果 <code>string</code> 参数不是原始字符串，那么该方法将不作任何改变地返回。</li><li><code>eval(function f()&#123;&#125;)</code> 返回 <code>function f()&#123;&#125;</code> 也就是 <code>true</code>。</li><li>结果为<code>1function</code>。</li></ul><H3> 在JavaScript中创建一个真正的private方法有什么缺点 </H3><p>每一个对象都会创建一个<code>private</code>方法的方法，这样很耗费内存</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var Employee = function (name, company, salary) &#123;</span><br><span class="line">    this.name = name || &quot;&quot;;</span><br><span class="line">    this.company = company || &quot;&quot;;</span><br><span class="line">    this.salary = salary || 5000;</span><br><span class="line"></span><br><span class="line">    // Private method</span><br><span class="line">    var increaseSalary = function () &#123;</span><br><span class="line">        this.salary = this.salary + 1000;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // Public method</span><br><span class="line">    this.dispalyIncreasedSalary = function() &#123;</span><br><span class="line">        increaseSlary();</span><br><span class="line">        console.log(this.salary);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Create Employee class object</span><br><span class="line">var emp1 = new Employee(&quot;John&quot;,&quot;Pluto&quot;,3000);</span><br><span class="line">// Create Employee class object</span><br><span class="line">var emp2 = new Employee(&quot;Merry&quot;,&quot;Pluto&quot;,2000);</span><br><span class="line">// Create Employee class object</span><br><span class="line">var emp3 = new Employee(&quot;Ren&quot;,&quot;Pluto&quot;,2500);</span><br></pre></td></tr></table></figure><p>在这里 <code>emp1,emp2,emp3</code>都有一个<code>increaseSalary</code>私有方法的副本。所以除非必要，非常不推荐使用私有方法。</p><H3> JavaScript中什么是闭包？写出一个例子 </H3><ul><li>闭包是在一个函数里声明了另外一个函数，并且这个函数访问了父函数作用域里的变量。</li><li>下面给出一个闭包例子，它访问了三个域的变量。<ul><li>它自己作用域的变量</li><li>父函数作用域的变量</li><li>全局作用域的变量</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var globalVar = &quot;abc&quot;;</span><br><span class="line"></span><br><span class="line">// Parent self invoking function</span><br><span class="line">(function outerFunction (outerArg) &#123; // begin of scope outerFunction</span><br><span class="line">    // Variable declared in outerFunction function scope</span><br><span class="line">    var outerFuncVar = &#x27;x&#x27;;</span><br><span class="line">    // Closure self-invoking function</span><br><span class="line">    (function innerFunction (innerArg) &#123; // begin of scope innerFunction</span><br><span class="line">        // variable declared in innerFunction function scope</span><br><span class="line">        var innerFuncVar = &quot;y&quot;;</span><br><span class="line">        console.log(</span><br><span class="line">            &quot;outerArg = &quot; + outerArg + &quot;\n&quot; +</span><br><span class="line">            &quot;outerFuncVar = &quot; + outerFuncVar + &quot;\n&quot; +</span><br><span class="line">            &quot;innerArg = &quot; + innerArg + &quot;\n&quot; +</span><br><span class="line">            &quot;innerFuncVar = &quot; + innerFuncVar + &quot;\n&quot; +</span><br><span class="line">            &quot;globalVar = &quot; + globalVar);</span><br><span class="line"></span><br><span class="line">    &#125;)(5); // end of scope innerFunction, Pass 5 as parameter</span><br><span class="line">&#125;)(7); // end of scope outerFunction, Pass 7 as parameter</span><br><span class="line">// innerFunction is closure that is defined inside outerFunc</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">outerArg = 7</span><br><span class="line">outerFuncVar = x</span><br><span class="line">innerArg = 5</span><br><span class="line">innerFuncVar = y</span><br><span class="line">globalVar = abc</span><br></pre></td></tr></table></figure><H3> 写一个mul函数 </H3><p>要求使用如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(mul(2)(3)(4)); // output : 24</span><br><span class="line">console.log(mul(4)(3)(4)); // output : 48</span><br></pre></td></tr></table></figure><p>参考函数如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function mul (x) &#123;</span><br><span class="line">    return function (y) &#123; // anonymous function</span><br><span class="line">        return function (z) &#123; // anonymous function</span><br><span class="line">            return x * y * z;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>mul</code>返回一个匿名函数，运行这个匿名函数又返回一个匿名函数，最里面的匿名函数可以访问 <code>x,y,z</code> 进而算出乘积返回即可。</li><li>对于<code>JavaScript</code>中的函数一般可以考察如下知识点<ul><li>函数是一等公民</li><li>函数可以有属性，并且能连接到它的构造方法</li><li>函数可以像一个变量一样存在内存中</li><li>函数可以当做参数传给其他函数</li><li>函数可以返回其他函数</li></ul></li></ul><H3> JavaScript怎么清空数组 </H3><p>例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arrayList = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;];</span><br></pre></td></tr></table></figure><ul><li>直接改变arrayList所指向的对象，原对象并不改变。<code>arrayList = []</code></li><li>这种方法通过设置length=0 使原数组清除元素。<code>arrayList.length = 0</code></li><li>和方法2相似。<code>arrayList.splice(0, arrayList.length)</code></li></ul><H3> 怎么判断一个object是否是数组(array) </H3><ul><li>Object.prototype.toString<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function isArray(obj)&#123;</span><br><span class="line">    return Object.prototype.toString.call( obj ) === &#x27;[object Array]&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>使用 原型链 (实例如果是某个构造函数构造出来的那么 它的 __proto__是指向构造函数的 prototype属性)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function isArray(obj)&#123;</span><br><span class="line">    return obj.__proto__ === Array.prototype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><H3> 下面代码输出什么 </H3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var output = (function(x)&#123;</span><br><span class="line">    delete x;</span><br><span class="line">    return x;</span><br><span class="line">&#125;)(0);</span><br><span class="line"></span><br><span class="line">console.log(output);</span><br></pre></td></tr></table></figure><p>输出是 0。 <code>delete</code> 操作符是将<code>object</code>的属性删去的操作。但是这里的 <code>x</code> 并不是对象的属性， <code>delete</code> 操作符并不能作用。</p><H3> 下面代码输出什么 </H3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line">var output = (function()&#123;</span><br><span class="line">    delete x;</span><br><span class="line">    return x;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">console.log(output);</span><br></pre></td></tr></table></figure><p>输出是 1。<code>delete</code> 操作符是将<code>object</code>的属性删去的操作。但是这里的<code>x</code>是并不是对象的属性，<code>delete</code>操作符并不能作用。</p><H3> 下面代码输出什么 </H3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var x = &#123; foo : 1&#125;;</span><br><span class="line">var output = (function()&#123;</span><br><span class="line">    delete x.foo;</span><br><span class="line">    return x.foo;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">console.log(output);</span><br></pre></td></tr></table></figure><p>输出是 <code>undefined</code>。<code>x</code>虽然是全局变量，但是它是一个<code>object</code>。<code>delete</code>作用在<code>x.foo</code>上，成功的将<code>x.foo</code>删去。所以返回<code>undefined</code></p><H3> 下面代码输出什么 </H3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var Employee = &#123;</span><br><span class="line">    company: &#x27;xyz&#x27;</span><br><span class="line">&#125;</span><br><span class="line">var emp1 = Object.create(Employee);</span><br><span class="line">delete emp1.company</span><br><span class="line">console.log(emp1.company);</span><br></pre></td></tr></table></figure><p>输出是 <code>xyz</code>，这里的 <code>emp1</code> 通过 <code>prototype</code> 继承了 <code>Employee的 company</code>。<code>emp1</code>自己并没有<code>company</code>属性。所以<code>delete</code>操作符的作用是无效的。</p><H3> 什么是 undefined x 1 </H3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var trees = [&quot;redwood&quot;,&quot;bay&quot;,&quot;cedar&quot;,&quot;oak&quot;,&quot;maple&quot;];</span><br><span class="line">delete trees[3];</span><br><span class="line">console.log(trees);</span><br></pre></td></tr></table></figure><ul><li>当我们使用 <code>delete</code> 操作符删除一个数组中的元素，这个元素的位置就会变成一个占位符。打印出来就是<code>undefined x 1</code>。 注意如果我们使用<code>trees[3] === &#39;undefined × 1&#39;</code>返回的是 <code>false</code>。因为它仅仅是一种打印表示，并不是值变为<code>undefined x 1</code>。</li><li>注：我自己没有复现</li></ul><H3> 下面代码输出什么 </H3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var trees = [&quot;xyz&quot;,&quot;xxxx&quot;,&quot;test&quot;,&quot;ryan&quot;,&quot;apple&quot;];</span><br><span class="line">delete trees[3];</span><br><span class="line"></span><br><span class="line">console.log(trees.length);</span><br></pre></td></tr></table></figure><p>输出是5。因为<code>delete</code>操作符并不是影响数组的长度。</p><H3> 下面代码输出什么 </H3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var bar = true;</span><br><span class="line">console.log(bar + 0);</span><br><span class="line">console.log(bar + &quot;xyz&quot;);</span><br><span class="line">console.log(bar + true);</span><br><span class="line">console.log(bar + false);</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">truexyz</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>下面给出一个加法操作表</p><ul><li>Number + Number -&gt; 加法</li><li>Boolean + Number -&gt; 加法</li><li>Boolean + Boolean -&gt; 加法</li><li>Number + String -&gt; 连接</li><li>String + Boolean -&gt; 连接</li><li>String + String -&gt; 连接</li></ul><H3> 下面代码输出什么 </H3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var z = 1, y = z = typeof y;</span><br><span class="line">console.log(y);</span><br></pre></td></tr></table></figure><p>输出是 <code>undefined</code>。<code>js</code>中赋值操作结合律是右至左的 ，即从最右边开始计算值赋值给左边的变量。</p><p>上面代码等价于</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var z = 1</span><br><span class="line">z = typeof y;</span><br><span class="line">var y = z;</span><br><span class="line">console.log(y);</span><br></pre></td></tr></table></figure><H3> 下面代码输出什么 </H3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var foo = function bar()&#123; return 12; &#125;;</span><br><span class="line">typeof bar();</span><br></pre></td></tr></table></figure><p>输出是抛出异常，<code>bar is not defined</code>。 如果想让代码正常运行，需要这样修改代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var bar = function()&#123; return 12; &#125;;</span><br><span class="line">typeof bar();</span><br></pre></td></tr></table></figure><p>或者是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function bar()&#123; return 12; &#125;;</span><br><span class="line">typeof bar();</span><br></pre></td></tr></table></figure><H3> 下面代码输出什么 </H3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(foo)</span><br><span class="line">console.log(bar)</span><br><span class="line"></span><br><span class="line">var foo = function()&#123;</span><br><span class="line">    // Some code</span><br><span class="line">&#125;;</span><br><span class="line">function bar()&#123;</span><br><span class="line">    // Some code</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">undefined</span><br><span class="line">function bar()&#123;</span><br><span class="line">    // Some code</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>JavaScript</code>在执行时，会将变量提升。所以上面代码<code>JavaScript</code> 引擎在实际执行时按下面这个顺序执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// foo bar的定义位置被提升</span><br><span class="line">function bar()&#123;</span><br><span class="line">    // Some code</span><br><span class="line">&#125;;</span><br><span class="line">var foo;</span><br><span class="line"></span><br><span class="line">console.log(foo)</span><br><span class="line">console.log(bar)</span><br><span class="line"></span><br><span class="line">foo = function()&#123;</span><br><span class="line">    // Some code</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><H3> 下面代码输出什么 </H3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var salary = &quot;1000$&quot;;</span><br><span class="line"></span><br><span class="line">(function () &#123;</span><br><span class="line">    console.log(&quot;Original salary was &quot; + salary);</span><br><span class="line"></span><br><span class="line">    var salary = &quot;5000$&quot;;</span><br><span class="line"></span><br><span class="line">    console.log(&quot;My New Salary &quot; + salary);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>这道题同样考察的是变量提升。等价于以下代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var salary = &quot;1000$&quot;;</span><br><span class="line"></span><br><span class="line"> (function () &#123;</span><br><span class="line">     var salary ;</span><br><span class="line">     console.log(&quot;Original salary was &quot; + salary);</span><br><span class="line"></span><br><span class="line">     salary = &quot;5000$&quot;;</span><br><span class="line"></span><br><span class="line">     console.log(&quot;My New Salary &quot; + salary);</span><br><span class="line"> &#125;)();</span><br></pre></td></tr></table></figure><p>所以输出为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Original salary was undefined</span><br><span class="line">My New Salary 5000$</span><br></pre></td></tr></table></figure><H3> 什么是 instanceof 操作符？下面代码输出什么 </H3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">  return foo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(new foo() instanceof foo);</span><br></pre></td></tr></table></figure><ul><li>instanceof操作符用来判断当前对象是否是特定类的对象。如:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Animal()&#123;</span><br><span class="line">    //或者不写return语句</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line">var dog = new Animal();</span><br><span class="line">dog instanceof Animal // Output : true</span><br></pre></td></tr></table></figure></li><li>但是，这里的foo定义为<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">  return foo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>所以<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// here bar is pointer to function foo()&#123;return foo&#125;.</span><br><span class="line">var bar = new foo();</span><br></pre></td></tr></table></figure>所以 <code>new foo() instanceof foo</code> 返回 <code>false</code></li></ul><H3> 如果我们使用JavaScript的"关联数组"，我们怎么计算"关联数组"的长度 </H3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var counterArray = &#123;</span><br><span class="line">    A : 3,</span><br><span class="line">    B : 4</span><br><span class="line">&#125;;</span><br><span class="line">counterArray[&quot;C&quot;] = 1;</span><br><span class="line">Object.keys(counterArray).length // Output 3</span><br></pre></td></tr></table></figure><p>直接计算key的数量就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> 前端面试题 </category>
          
          <category> Js篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 前端面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020年元旦北京游玩记录</title>
      <link href="/2021/08/05/%E5%8C%97%E4%BA%AC%E7%AB%99/"/>
      <url>/2021/08/05/%E5%8C%97%E4%BA%AC%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<p>2020年1月1日的时候还没有疫情，再加上元旦(星期三)放假一天，请两天假的话刚好有5天假期，于是就萌生了去北京玩耍的想法。选北京的理由很简单：某个南方人没有感受过北方的冬天！这次去北京其实比较仓促，虽说不上是临时起意，说走就走，但也差不多是这个意思。而我们旅行的风格一贯是以舒适为主，所以这趟行程依旧很简单。</p><H3> 2020.01.01 上海 - 2020.01.01 北京 </H3><ol><li><p>出发的时候考量了机票和火车票的价格，发现差不多，但是机场离市区更远，于是依然选择了从火车站坐高铁出发。1月1号早上起了个大早，6点半从上海虹桥出发到了北京南是中午12点半左右，然后又换乘地铁去了酒店。当时选酒店的时候就特意选了中心位置，这样方便去各个景区。在多个APP上对照性价比之后，终于在去哪儿上找到了这家酒店，预定了4天。办理入住之后发现真的是捡到宝了，首先酒店在汪芝麻胡同，地理位置相当不错；其次酒店虽然不大，但是环境还挺不错；当然最重要的是价格还便宜。办理好入住之后，简单吃了点东西就直奔五道口去了。</p></li><li><p>因为我们的行程安排是下午去参观北大、清华（事先我都预约了），感受一下站在北大、清华的感觉。但是由于事先做的攻略太匆忙，路线没搞好，结果就是绕着北大转了个大圈，脚都走痛了，等到了北大的校门口时已经过了预约的时间，最后就是站在北大的校门口遥望了一下。然后就去了圆明园，圆明园公园也真的大，再加上是冬天的傍晚，园子里树木萧条，空中一直在传来乌鸦的嘎嘎叫声，就让我脑子里顿时各种图画跑来跑去，再加上走了一下午脚疼的厉害，也饿的厉害，我们就决定离开这里，回去吃饭。</p></li><li><p>导航了一下，发现回酒店的路上可以经过西单，然后就先去了传说中的西单，结果去了西单发现跟上海的南京东路差不多，都是商场，人也一样的多，没别的特殊之处。最后去了和府捞面吃了碗面，就回酒店休息了。</p></li></ol><H3> 2020.01.02 故宫 + 恭王府 </H3><ol><li><p>1月2号早上7点出发去了街对面的护国寺小吃店吃了焦圈、包子、油条、豆浆（没敢尝试豆汁），然后直奔故宫而去。差不多8点多就到了天安门广场，然后排队安检准备进入天安门广场，可能是因为冬天的缘故，虽然是元旦，但是排队的人不多，很快我们就进入了天安门广场。天安门广场很大，以前都是在视频中看天安门广场，现在亲身站在这里的时候，还是有种不真实的感觉。。。</p><div style="display: flex; justify-content: center"> <img src="/img/beijing/2.jpeg" height="300" width="200" style="margin-right: 8px"> <img src="/img/beijing/3.jpeg" height="300" width="200" ></div></li><li><p>从地下通道穿过天安门广场就到了故宫的城楼，从城楼底下的小门进去就算是进入紫禁城了，这时候你会看到一条宽敞的直道直通午门，道路左右是一些树木和平房。然后走一段距离之后就可以检票穿过午门正式进入故宫博物馆了。大家都知道故宫是以午门-太和门-太和殿-乾清门-神武门为中轴线分东西六宫的，故宫实在是太大了，我们只参观了中轴线上的宫殿，然后绕了西六宫，当时正值寿康宫开放展览，于是就参观了嬛嬛的寿康宫，以及华妃娘娘的翊坤宫。然后穿过御花园，歇了一下脚，畅想了一番清宫剧里御花园皇帝与后妃的经典戏码。然后登上神武门的城楼，遥望着对面的景山公园，想象当初崇祯皇帝吊死时的悲愤与无奈。。。在城楼上发了会呆，实在又饿又累就没有继续去东六宫了，然后从神武门出来，结束了上午的故宫之行。</p><div style="display: flex; justify-content: center"> <img src="/img/beijing/4.jpeg" height="200" width="200" style="margin-right: 8px"> <img src="/img/beijing/5.jpeg" height="200" width="200" style="margin-right: 8px"> <img src="/img/beijing/6.jpeg" height="200" width="200"></div><div style="display: flex; justify-content: center; margin-top: 8px"> <img src="/img/beijing/7.jpeg" height="200" width="200" style="margin-right: 8px"> <img src="/img/beijing/8.jpeg" height="200" width="200" style="margin-right: 8px"> <img src="/img/beijing/9.jpeg" height="200" width="200" ></div></li><li><p>从神武门出来，刚好有个大爷卖冰糖葫芦，买了一串吃了之后发现果然现在哪里的冰糖葫芦都是一个味，没有小时候冰糖葫芦的味道（我是北方人，小时候冬天经常吃冰糖葫芦）。然后就去了后海那一片，中午找了家胡同的铜锅涮肉，味道真心不错，吃过饭之后刚好下午2点多，然后就绕着后海走路去了雍王府。</p><div align="center"> <img src="/img/beijing/10.jpeg" height="200" width="200"></div></li><li><p>恭王府是和珅和后来的恭亲王奕䜣的府邸，大是必然的，我们绕着园子走了一圈，不免感概了一番，这座大园子可都是靠着人民群众供养着呀。</p><div style="display: flex; justify-content: center"> <img src="/img/beijing/11.jpeg" height="200" width="200" style="margin-right: 8px"> <img src="/img/beijing/12.jpeg" height="200" width="200" style="margin-right: 8px"> <img src="/img/beijing/13.jpeg" height="200" width="200" ></div></li><li><p>恭王府离北海公园很近，但是由于我怕冷穿了双加绒的靴子，走了一天了，脚不争气，实在是挪不到北海公园的大门口，再加上从恭王府出来已经快5点了，北海公园也快要闭园了，然后就没有去，吃过饭就直接回酒店歇息了。</p></li></ol><H3> 2020.01.03 前门大栅栏 + 八大胡同 + 铜锣鼓巷 </H3><ol><li><p>本来打算是1月3号去长城的，但是前一天走了一天路，腿脚有点累就临时改了行程，在市里转悠了一天。先是睡到自然醒，然后就出门去了前门。在前门大街转悠了一圈之后就找了家店吃午餐，吃了老北京杂酱面、北京烤鸭、炙羊肉。期间还在德云社门口转悠了半天，也没进去，现在想来该买张票进去坐坐的，咳！</p><div style="display: flex; justify-content: center"> <img src="/img/beijing/14.jpeg" height="200" width="200" style="margin-right: 8px"> <img src="/img/beijing/15.jpeg" height="200" width="200" style="margin-right: 8px"> <img src="/img/beijing/16.jpeg" height="200" width="200"></div></li><li><p>吃过饭之后就去找八大胡同了，因为不知道八大胡同到底是个啥，然后就跟着导航使劲找，看着导航上明明已经是在八大胡同了，但是找不到标示，一直跟着导航转圈圈，转了半天才突然意识到人已经在八大胡同里了，它就是八条胡同呀，一场乌龙，但是在这里我吃到了很好吃的鸡蛋灌饼。然后我们就出了胡同朝着铜锣鼓巷的方向溜达，一边溜达一边感慨站在北京的土地上，哪里哪里都是文化底蕴的气息，而且北京人说话真好玩，听着就端庄大气。就这样一路走一路吃到了铜锣鼓巷，铜锣鼓巷其实就是一条商业化的步行街，跟其他城市的的步行街一样，浓浓的商业气息。我们还是在这条街上吃了晚饭，晚饭吃的啥完全没印象了。然后在一家人本的帆布鞋店买了两双帆布鞋，为明天的爬长城作准备。之后就又溜达回了酒店。一天就这样结束了，其实这一天应该安排去颐和园的，最终没有去颐和园，真是遗憾！</p></li></ol><H3> 2020.01.04 长城 + 奥林匹克公园 </H3><ol><li><p>1月4号我们按照计划出发去八达岭长城了，我们没有买直达长城的班车票，自信地选择了自己坐公交去，结果中间换乘了公交就不说了，然后快到长城的时候，由于判断失误在八达岭国家森林公园下车了，然后又等了一趟公交车才顺利到达长城，晕！但总算是到达了，看到长城的时候还是很震撼的，还信誓旦旦地说一定要绕一圈。然后就开始了长城之旅，刚开始感觉还好，台阶不是很陡，爬到北8楼的时候就爬不动了，平时不锻炼体力太差了，然后我就选择坐在大石头上看别人照相，某人继续往前走。一个人坐了一会，发了会呆，不知道为什么就想到了孟姜女哭长城，然后就想到了古代劳动人民筑造长城的不容易，多少人为此丧生，又有多少家庭为此破碎，想着想着心情就低落了下来，就想下去了。但是实在太累了，正所谓上山容易下山难，还是选择了坐着滑轮车下去。在出口处汇合后就坐车返回了，我甚至都不记得回去的时候的路费是多少，只记得是大巴车走了好久才回市里。</p><div style="display: flex; justify-content: center"> <img src="/img/beijing/17.jpeg" height="200" width="200" style="margin-right: 8px"> <img src="/img/beijing/18.jpeg" height="200" width="200"></div></li><li><p>回到市里后，回酒店的路上经过了奥林匹克公园，就顺路去里面转了转，然后就晚上了，在奥林匹克公园的一个广场里找了家饭店吃了晚饭，点了老北京灌肠（其实我们老家也有灌肠这种东西，只是我们叫碗团）、京酱肉丝、葱爆羊肉。吃完饭就乘坐地铁回酒店了，结束了北京之行。</p><div align="center"> <img src="/img/beijing/19.jpeg" height="200" width="200"></div></li></ol><H3> 2020.01.05 北京 - 2020.01.05 上海 </H3><p>5号上午交了房就坐动车回了上海，选择5号回去也是为了可以调整休息一下，然后就又要继续搬砖了。</p><H3> 结语 </H3><ol><li><p>这趟北京之行也是很简单宽松的路线，整体上来说还是可以的。北京的景点太多了，可去的地方也太多了，5天是真的不够，考虑以后抽时间再多去几次，还有就是北京的景点门票真心便宜。要是把去八大胡同、铜锣鼓巷的时间分配给颐和园，把去圆明园的时间分给北海公园就更好了！总之大首都还是值得多去几次的地方！</p></li><li><p>大概费用统计如下：</p><table><thead><tr><th>日期</th><th>路费</th><th>住宿费</th><th>门票费</th><th>吃吃喝喝</th><th>总计(元)</th><th>累计(元)</th></tr></thead><tbody><tr><td>10月1号</td><td>550*2</td><td>195</td><td>10*2</td><td>200</td><td>1515</td><td>1515</td></tr><tr><td>10月2号</td><td>地铁费忽略不计</td><td>195</td><td>40<em>2 + 40</em>2</td><td>400</td><td>755</td><td>2270</td></tr><tr><td>10月3号</td><td>-</td><td>195</td><td>-</td><td>600（加两双帆布鞋）</td><td>795</td><td>3065</td></tr><tr><td>10月4号</td><td>60*4（往返）</td><td>195</td><td>35*2 + 80（滑轮车）</td><td>400</td><td>885</td><td>3155</td></tr><tr><td>10月5号</td><td>550*2</td><td>-</td><td>-</td><td>-</td><td>1100</td><td>4255</td></tr><tr><td>加上高铁上的餐食以及乱七八糟的零食、水之类的大概就是4500左右吧！</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></li></ol>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
          <category> 游记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 旅行 </tag>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019年国庆四川游玩记录</title>
      <link href="/2021/08/03/%E5%9B%9B%E5%B7%9D%E7%AB%99/"/>
      <url>/2021/08/03/%E5%9B%9B%E5%B7%9D%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<H3> 写在开头的话 </H3><p>2019年国庆的时候还没有疫情，祖国山河一片大好。彼时笔者还是携程的一个“螺丝钉”，虽然是一个“螺丝钉”，但是依然也是有旅行福利的–几百块钱的旅行酒店住宿补助，感谢携程！不管是出于要花掉这笔钱的想法（不用会作废），还是出于想见见祖国大美山河的想法，总之是在国庆这个人潮汹涌的旅行高峰时节出发去了四川。</p><p>出发前做了攻略，四川的很多地方我都想去，但是考虑到路程、时间、人流量的问题，再加上我出去玩的目的只是放空心情，并不想搞的行程太紧、人疲惫不堪。所以我们两个人最终就选了成都-都江堰-成都这样简单的游玩路线。</p><H3> 2019.10.01 上海 - 019.10.01 成都 </H3><ol><li><p>由于国庆的机票价格贵的吓人，而我们定的路线时间也比较宽裕，再加上住的地方离虹桥很近，综合考虑下就选择了动车。于是10月1号早上6点多从上海虹桥出发，晚上8点多到达了成都，酒店都是提前定好的，包括都江堰的酒店也是提前预定的（这里还有一个小插曲，等到讲都江堰的时候再讲）。到了成都之后就回酒店放东西，打算晚上逛逛夜市，然后到了酒店之后我就惊呆了，跟我预想的完全不一样，跟我在美团APP上看到的也完全不一样。更令人郁闷的是我还预定了两晚。有必要说一下，各位朋友出去玩耍的时候一定要找好酒店，建议在携程、去哪儿上看，美团上的酒店虽然看着便宜但是坑太多了。</p></li><li><p>收拾收拾就出发去锦里逛街了，因为酒店就在锦里附近，步行了一会就到了。到了锦里之后看到好多好吃的，瞬间幸福感爆棚，再加上一直在动车上就只吃了动车上的速食餐，早已饥肠辘辘了，于是就开启了逛吃模式。某人还去感受了一下洗耳。很多照片找不到了，勉强找到三张。</p><div style="display: flex; justify-content: center"> <img src="/img/sichuan/2.jpeg" height="300" width="190" > <img src="/img/sichuan/3.jpeg" height="300" width="190" > <img src="/img/sichuan/4.jpeg" height="300" width="190" ></div></li><li><p>逛到10点多的时候，就原路返回了酒店，在回酒店的路边摊上我吃到了一份卤粉条，真的好吃到爆，现在想起来还会流哈喇子。。。这样就结束了来成都的第一天。</p></li></ol><H3> 2019.10.02 成都 </H3><ol><li><p>10月2号我们选择在成都市內逛一天，早上起来我们去了宽窄巷子逛了逛，照样是吃吃喝喝，在这里吃到了一家很好吃的早餐店。</p><div style="display: flex; justify-content: center"> <img src="/img/sichuan/5.jpeg" height="300" width="190" > <img src="/img/sichuan/6.jpeg" height="300" width="190" ></div></li><li><p>10点多的时候去了大熊猫繁育研究基地，熊猫园好大呀！人也好多呀！印象中最深刻的就是为了看刚出生的大熊猫宝宝，竟然排了将近1个小时的长队，但是只隔着玻璃看了不到2分钟。当看到一团毛绒绒的团子时，排队的辛苦也就不算什么了。</p><div style="display: flex; justify-content: center"> <img src="/img/sichuan/7.jpeg" height="300" width="190" > <img src="/img/sichuan/8.jpeg" height="300" width="190" > <img src="/img/sichuan/9.jpeg" height="300" width="190" ></div></li><li><p>逛完熊猫基地之后就下午2点多了，然后返回了市区吃了算是正宗的川菜–麻婆豆腐、宫保鸡丁、红烧鱼，想吃的太多了，但是两个人又吃不掉，好可惜，更可惜的是没有照片了。。。吃完饭在街上溜达溜达就到晚上了，晚上去看了川剧，喝了盖碗茶，可惜的是没买到靠前的票，坐的有点远。。。。看川剧的感受就是唱的戏文真心听不懂，但是川剧变脸看的还是挺震撼的，尤其是喝着茶，听着戏，心情是真的会放松下来。</p><div align="center"><img src="/img/sichuan/10.jpeg" height="300" width="190" ></div></li><li><p>听完戏之后就差不多10点了，然后我们就走路回去了酒店，再回酒店的路上，到处都能看到马路街边有人们坐在竹椅上，扇着扇子，喝着茶，聊着天，真心惬意。</p></li></ol> <H3> 2019.10.03 成都 - 2019.10.03 都江堰 </H3><ol><li><p>10月3号早上我们便动身去都江堰了，选择去都江堰的目的是想避开人群，但其实根本避不开，照样是人挤人。因为在都江堰预定的酒店就在都江堰景区附近，所以就选择了乘坐大巴直达过去。在去汽车站的路上我吃到了一个牛肉包子，是在路边摊买的，好吃到爆，心想从都江堰回来成都的时候我还要再买一个，但是回来的时候竟然就没见到了。。。</p></li><li><p>11点多的时候到达了都江堰，我们直奔酒店入住，但是到了酒店的时候，前台两个人在嘀嘀咕咕，然后跟我们说是客房还在打扫，还不能办理入住，要我们先把行李寄存在这里，等1点多的时候才可以办理入住。我心想也好，反正我们也是想直接去景区的，就同意了这一提议，整理好东西准备出门的时候，大堂经理突然跟我说我们可赚了，由于我是提前预定的酒店，当时是170预定的，大堂经理说我们这个房型现在500多，还非常紧俏。对比成都的酒店，心情便又愉悦了几分。于是跟大堂经理寒暄了两句，我们便出门了。</p></li><li><p>在景区门口的一个小饭店点了红油抄手、卤菜、酸菜鱼当作午餐，真的要吹爆四川的卤菜，不管是在成都还是在都江堰，卤菜是做的真心好吃。吃完饭我们便去了都江堰景区。景区是真的大，走走停停一下午。总体上总结就是看了水，过了桥，爬了山。等下山的时候就5点多了，下山赶紧回去酒店办了入住，打开房门的时候，感慨一声：酒店诚不欺我，上一次住这么好的酒店还是在泰国的时候。</p><div style="display: flex; justify-content: center"><img src="/img/sichuan/11.jpeg" height="300" width="190" ><img src="/img/sichuan/12.jpeg" height="300" width="190" ><img src="/img/sichuan/13.jpeg" height="300" width="190" ><img src="/img/sichuan/14.jpeg" height="300" width="190" ></div></li><li><p>在酒店歇了会脚之后，便到了晚饭时间，晚饭我们选择去酒店附近的都江堰步行街吃小吃，这条街还是挺大的，我们吃吃喝喝逛完回去酒店的时候都9点多了。想说的是灯光真是伟大的发明，跟所有的城市一样，晚上的都江堰跟白天的都江堰截然不同。。。</p><div style="display: flex; justify-content: center"><img src="/img/sichuan/15.jpeg" height="300" width="190" ><img src="/img/sichuan/16.jpeg" height="300" width="190" ></div></li></ol> <H3> 2019.10.04 都江堰 - 2019.10.04 成都 </H3><ol><li><p>由于头天在都江堰景区走的时间太长了，再加上爬了山，太累了。导致10月4号的青城山之行就取消了，也就避免了早起，于是舒舒服服地睡到了10月4号的中午，起床收拾了东西，退了房就去了汽车站。等回到成都的时候已经是下午快3点了，早已是饥肠辘辘，心心念念的牛肉包也不见了（估计是只有早上卖），实在是饿了，便也没挑地方，找了个“苍蝇馆子”垫巴垫巴。没成想点了个小笼包竟然超级好吃，不知道是不是饿了的缘故，就觉得比平时吃到的好吃。</p></li><li><p>第二天又是早早的动车，所以就把房间定在了高铁站附近，垫巴完肚子便出发去找住宿的房间了，贪便宜订的这个房间是在一个小区內，真是一顿好找哇，终于找到之后也累的歇菜了。但是有一说一，这个房间还是可以的。等到6点多的时候，在一个广场里找了一家火锅店，以一顿热辣的火锅结束了这趟四川之旅。</p><div align="center"><img src="/img/sichuan/17.jpeg" height="200" width="200" ></div></li></ol><H3> 2019.10.05 成都 - 2019.10.05 上海 </H3><p>早上起了个大早便坐动车回了上海。</p><H3> 结语 </H3><ol><li><p>这趟四川之行总体上来说就是吃吃喝喝的一趟旅行，安排的行程很宽松，吃的很多东西也都是路边摊，两个人都很满意，这大概就是自由行的特点吧。</p></li><li><p>大概费用统计如下：</p><table> <tr>     <th></th>     <th>路费</th>     <th>住宿费</th>     <th>门票费</th>     <th>吃吃喝喝</th>     <th>总计(元)</th> </tr> <tr>     <td>10月1号</td>     <td>690*2</td>     <td>190</td>     <td>-</td>     <td>200+(加洗耳60)</td>     <td>1770左右</td> </tr> <tr>     <td>10月2号</td>     <td>地铁费忽略不计</td>     <td>190</td>     <td>52*2 + 80*2</td>     <td>240+</td>     <td>694左右</td> </tr> <tr>     <td>10月3号</td>     <td>20*2</td>     <td>170</td>     <td>78*2</td>     <td>200+</td>     <td>566左右</td> </tr> <tr>     <td>10月4号</td>     <td>20*2</td>     <td>160</td>     <td>-</td>     <td>240+</td>     <td>440左右</td> </tr> <tr>     <td>10月5号</td>     <td>690*2</td>     <td>-</td>     <td>-</td>     <td>-</td>     <td>1380</td> </tr> <tr>     <td>5天总计费用(元)</td>     <td colspan="5">4850</td> </tr></table>加上动车上的餐食以及乱七八糟的零食、水之类的大概就是5000左右吧，最主要的花销还是路费!</li></ol>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
          <category> 游记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 旅行 </tag>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES8、ES9、ES10、ES11常用特性</title>
      <link href="/2021/08/03/ES8%E3%80%81ES9%E3%80%81ES10%E3%80%81ES11%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7/"/>
      <url>/2021/08/03/ES8%E3%80%81ES9%E3%80%81ES10%E3%80%81ES11%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<H3> ES8(ES2017)新特性 </H3><ol><li>对象新增方法<ul><li>Object.values()：返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const obj = &#123; foo: &#x27;bar&#x27;, baz: 42 &#125;;</span><br><span class="line">Object.values(obj)</span><br><span class="line">// [&quot;bar&quot;, 42]</span><br><span class="line"></span><br><span class="line">const obj = &#123; 100: &#x27;a&#x27;, 2: &#x27;b&#x27;, 7: &#x27;c&#x27; &#125;;</span><br><span class="line">Object.values(obj)</span><br><span class="line">// [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;]属性名为数值的属性，是按照数值大小，从小到大遍历的，因此返回的顺序是b、c、a。</span><br></pre></td></tr></table></figure></li><li>Object.entries()：返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。基本用途是遍历对象的属性。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const obj = &#123; foo: &#x27;bar&#x27;, baz: 42 &#125;;</span><br><span class="line">Object.entries(obj)</span><br><span class="line">// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]</span><br><span class="line"></span><br><span class="line">let obj = &#123; one: 1, two: 2 &#125;;</span><br><span class="line">for (let [k, v] of Object.entries(obj)) &#123;</span><br><span class="line">console.log(</span><br><span class="line">    `$&#123;JSON.stringify(k)&#125;: $&#123;JSON.stringify(v)&#125;`</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">// &quot;one&quot;: 1</span><br><span class="line">// &quot;two&quot;: 2</span><br></pre></td></tr></table></figure></li><li>Object.getOwnPropertyDescriptors()：<code>ES5</code> 的<code>Object.getOwnPropertyDescriptor()</code>方法会返回某个对象属性的描述对象（<code>descriptor</code>）。<code>ES2017</code> 引入了<code>Object.getOwnPropertyDescriptors()</code>方法，返回指定对象所有自身属性（非继承属性）的描述对象。如果没有任何自身属性，则返回空对象。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const source = &#123;</span><br><span class="line">set foo(value) &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const target1 = &#123;&#125;;</span><br><span class="line">Object.assign(target1, source);</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyDescriptor(target1, &#x27;foo&#x27;)</span><br><span class="line">// &#123; value: undefined,</span><br><span class="line">//   writable: true,</span><br><span class="line">//   enumerable: true,</span><br><span class="line">//   configurable: true &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>string新增方法<ul><li>padStart()和 padEnd()<br>如果某个字符串不够指定长度，会在头部或尾部补全。<code>padStart()</code>用于头部补全，<code>padEnd()</code>用于尾部补全。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;x&#x27;.padStart(5, &#x27;ab&#x27;) // &#x27;ababx&#x27;</span><br><span class="line">&#x27;x&#x27;.padStart(4, &#x27;ab&#x27;) // &#x27;abax&#x27;</span><br><span class="line"></span><br><span class="line">&#x27;x&#x27;.padEnd(5, &#x27;ab&#x27;) // &#x27;xabab&#x27;</span><br><span class="line">&#x27;x&#x27;.padEnd(4, &#x27;ab&#x27;) // &#x27;xaba&#x27;</span><br><span class="line"></span><br><span class="line">// 原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。</span><br><span class="line">&#x27;xxx&#x27;.padStart(2, &#x27;ab&#x27;) // &#x27;xxx&#x27;</span><br><span class="line">&#x27;xxx&#x27;.padEnd(2, &#x27;ab&#x27;) // &#x27;xxx&#x27;</span><br></pre></td></tr></table></figure></li></ul></li><li>async/await<ul><li>基本用法<br><code>async</code>函数返回一个<code>Promise</code>对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function getStockPriceByName(name) &#123;</span><br><span class="line">const symbol = await getStockSymbol(name);</span><br><span class="line">const stockPrice = await getStockPrice(symbol);</span><br><span class="line">return stockPrice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getStockPriceByName(&#x27;goog&#x27;).then(function (result) &#123;</span><br><span class="line">console.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ol><H3> ES9(ES2018)新特性 </H3><ol><li>异步迭代: <code>ES2018</code>引入异步迭代器（<code>asynchronous iterators</code>），这就像常规迭代器，除了<code>next()</code>方法返回一个<code>Promise</code>。因此<code>await</code>可以和<code>for...of</code>循环一起使用，以串行的方式运行异步操作。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function process(array) &#123;</span><br><span class="line">  for await (let i of array) &#123;</span><br><span class="line">    doSomething(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Promise.finally(): 一个<code>Promise</code>调用链要么成功到达最后一个<code>.then()</code>，要么失败触发<code>.catch()</code>。在某些情况下，你想要在无论<code>Promise</code>运行成功还是失败，运行相同的代码，例如清除，删除对话，关闭数据库连接等。<code>.finally()</code>允许你指定最终的逻辑。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function doSomething() &#123;</span><br><span class="line">  doSomething1()</span><br><span class="line">  .then(doSomething2)</span><br><span class="line">  .then(doSomething3)</span><br><span class="line">  .catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(() =&gt; &#123;</span><br><span class="line">    // finish here!</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Rest/Spread 属性: <code>ES2018</code>为对象解构提供了和数组一样的<code>Rest</code>参数（）和展开操作符。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const myObject = &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: 2,</span><br><span class="line">  c: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const &#123; a, ...x &#125; = myObject;</span><br><span class="line">// a = 1</span><br><span class="line">// x = &#123; b: 2, c: 3 &#125;</span><br><span class="line"></span><br><span class="line">restParam(&#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: 2,</span><br><span class="line">  c: 3</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">function restParam(&#123; a, ...x &#125;) &#123;</span><br><span class="line">  // a = 1</span><br><span class="line">  // x = &#123; b: 2, c: 3 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const obj1 = &#123; a: 1, b: 2, c: 3 &#125;;</span><br><span class="line">const obj2 = &#123; ...obj1, z: 26 &#125;;</span><br><span class="line">// obj2 is &#123; a: 1, b: 2, c: 3, z: 26 &#125;</span><br></pre></td></tr></table></figure></li><li>正则表达式命名捕获组: <code>ES2018</code>允许命名捕获组使用符号<code>?&lt;name&gt;</code>，在打开捕获括号<code>(</code>后立即命名。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const</span><br><span class="line">  reDate = /(?&lt;year&gt;[0-9]&#123;4&#125;)-(?&lt;month&gt;[0-9]&#123;2&#125;)-(?&lt;day&gt;[0-9]&#123;2&#125;)/,</span><br><span class="line">  match  = reDate.exec(&#x27;2018-04-30&#x27;),</span><br><span class="line">  year   = match.groups.year,  // 2018</span><br><span class="line">  month  = match.groups.month, // 04</span><br><span class="line">  day    = match.groups.day;   // 30</span><br></pre></td></tr></table></figure></li><li>正则表达式dotAll模式: 正则表达式中点<code>.</code>匹配除回车外的任何单字符，标记<code>s</code>改变这种行为，允许行终止符的出现。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/hello.world/.test(&#x27;hello\nworld&#x27;);  // false</span><br><span class="line">/hello.world/s.test(&#x27;hello\nworld&#x27;); // true</span><br></pre></td></tr></table></figure></li></ol><H3> ES10(ES2019)新特性 </H3><ol><li>新增对象方法<ul><li>Object.fromEntries(): <code>Object.entries()</code>的逆操作，用于将一个键值对数组转为对象。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object.fromEntries([</span><br><span class="line">[&#x27;foo&#x27;, &#x27;bar&#x27;],</span><br><span class="line">[&#x27;baz&#x27;, 42]</span><br><span class="line">])</span><br><span class="line">// &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>新增数组方法<ul><li>flat()，flatMap():<code>flat(</code>)默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将<code>flat()</code>方法的参数写成一个整数，表示想要拉平的层数，默认为1。<code>flatMap()</code>只能展开一层数组。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1, 2, [3, [4, 5]]].flat()</span><br><span class="line">// [1, 2, 3, [4, 5]]</span><br><span class="line"></span><br><span class="line">[1, 2, [3, [4, 5]]].flat(2)</span><br><span class="line">// [1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">//如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数</span><br><span class="line">[1, [2, [3]]].flat(Infinity)</span><br><span class="line">// [1, 2, 3]</span><br><span class="line"></span><br><span class="line">// 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()</span><br><span class="line">[1, 2, 3, 4].flatMap(x =&gt; [[x * 2]])</span><br><span class="line">// [[2], [4], [6], [8]]</span><br></pre></td></tr></table></figure></li></ul></li><li>新增string方法<ul><li>trimStart()和trimEnd(): <code>trimStart()</code>和<code>trimEnd()</code>这两个方法的行为与<code>trim()</code>一致，<code>trimStart()</code>消除字符串头部的空格，<code>trimEnd()</code>消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。<br>除了空格键，这两个方法对字符串头部（或尾部）的<code> tab</code> 键、换行符等不可见的空白符号也有效。浏览器还部署了额外的两个方法，<code>trimLeft()</code>是<code>trimStart()</code>的别名，<code>trimRight()</code>是<code>trimEnd()</code>的别名。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const s = &#x27;  abc  &#x27;;</span><br><span class="line"></span><br><span class="line">s.trim() // &quot;abc&quot;</span><br><span class="line">s.trimStart() // &quot;abc  &quot;</span><br><span class="line">s.trimEnd() // &quot;  abc&quot;</span><br></pre></td></tr></table></figure></li><li>matchAll(): 可以一次性取出所有匹配。不过，它返回的是一个遍历器（<code>Iterator</code>），而不是数组。<br>如果一个正则表达式在字符串里面有多个匹配，现在一般使用<code>g</code>修饰符或<code>y</code>修饰符，在循环里面逐一取出。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var regex = /t(e)(st(\d?))/g;</span><br><span class="line">var string = &#x27;test1test2test3&#x27;;</span><br><span class="line"></span><br><span class="line">var matches = [];</span><br><span class="line">var match;</span><br><span class="line">while (match = regex.exec(string)) &#123;</span><br><span class="line">matches.push(match);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">matches</span><br><span class="line">// [</span><br><span class="line">//   [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;, index: 0, input: &quot;test1test2test3&quot;],</span><br><span class="line">//   [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;, index: 5, input: &quot;test1test2test3&quot;],</span><br><span class="line">//   [&quot;test3&quot;, &quot;e&quot;, &quot;st3&quot;, &quot;3&quot;, index: 10, input: &quot;test1test2test3&quot;]</span><br><span class="line">// ]</span><br><span class="line"></span><br><span class="line">const string = &#x27;test1test2test3&#x27;;</span><br><span class="line">const regex = /t(e)(st(\d?))/g;</span><br><span class="line"></span><br><span class="line">for (const match of string.matchAll(regex)) &#123;</span><br><span class="line">console.log(match);</span><br><span class="line">&#125;</span><br><span class="line">// [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;, index: 0, input: &quot;test1test2test3&quot;]</span><br><span class="line">// [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;, index: 5, input: &quot;test1test2test3&quot;]</span><br><span class="line">// [&quot;test3&quot;, &quot;e&quot;, &quot;st3&quot;, &quot;3&quot;, index: 10, input: &quot;test1test2test3&quot;]</span><br></pre></td></tr></table></figure></li></ul></li><li>更加友好的 JSON.stringify: 如果输入 <code>Unicode </code>格式但是超出范围的字符，在原先<code>JSON.stringify</code>返回格式错误的<code>Unicode</code>字符串。现在实现了一个改变<code>JSON.stringify</code>的第3阶段提案，因此它为其输出转义序列，使其成为有效<code>Unicode</code>（并以UTF-8表示）。<br>为了确保返回的是合法的 <code>UTF-8</code> 字符，<code>ES2019</code> 改变了<code>JSON.stringify()</code>的行为。如果遇到<code>0xD800</code>到<code>0xDFFF</code>之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JSON.stringify(&#x27;\u&#123;D834&#125;&#x27;) // &quot;&quot;\\uD834&quot;&quot;</span><br><span class="line">JSON.stringify(&#x27;\uDF06\uD834&#x27;) // &quot;&quot;\\udf06\\ud834&quot;&quot;</span><br></pre></td></tr></table></figure></li></ol><H3> ES11(ES2020)新特性 </H3><ol><li>新增number数据类型: <code>JavaScript</code> 所有数字都保存成 64 位浮点数，这给数值的表示带来了两大限制。一是数值的精度只能到 53 个二进制位（相当于 16 个十进制位），大于这个范围的整数，<code>JavaScript</code> 是无法精确表示的，这使得 <code>JavaScript </code>不适合进行科学和金融方面的精确计算。二是大于或等于2的1024次方的数值，<code>JavaScript </code>无法表示，会返回<code>Infinity</code>。<code>ES2020</code>引入了一种新的数据类型 <code>BigInt</code>（大整数），来解决这个问题，这是 <code>ECMAScript</code> 的第八种数据类型。<code>BigInt</code> 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。<ul><li>为了与 Number 类型区别，BigInt 类型的数据必须添加后缀n。BigInt 与普通整数是两种值，它们之间并不相等。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1234 // 普通整数</span><br><span class="line">1234n // BigInt</span><br><span class="line"></span><br><span class="line">// BigInt 的运算</span><br><span class="line">1n + 2n // 3n</span><br><span class="line"></span><br><span class="line">42n === 42 // false</span><br><span class="line">typeof 123n // &#x27;bigint&#x27;</span><br></pre></td></tr></table></figure></li></ul></li><li>Optional Chaining 可选链式调用: 当我们正在访问一个不属于对象的属性时<code>JavaScript </code>引擎会抛出错误。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const flower = &#123;</span><br><span class="line">    colors: &#123;</span><br><span class="line">        red: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(flower.colors.red) // 正常运行</span><br><span class="line"></span><br><span class="line">console.log(flower.species.lily) // 抛出错误：TypeError: Cannot read property &#x27;lily&#x27; of undefined</span><br><span class="line"></span><br></pre></td></tr></table></figure>但是某些情况下值是否存在并不重要，因为我们知道它会存在。于是，可选链式调用就派上用场了！我们可以使用由一个问号和一个点组成的可选链式操作符，去表示不应该引发错误。如果没有值，应该返回 <code>undefined</code>。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let flowers =  [&#x27;lily&#x27;, &#x27;daisy&#x27;, &#x27;rose&#x27;]</span><br><span class="line">console.log(flowers[1]) // 输出：daisy</span><br><span class="line"></span><br><span class="line">flowers = null</span><br><span class="line">console.log(flowers[1]) // 抛出错误：TypeError: Cannot read property &#x27;1&#x27; of null</span><br><span class="line">console.log(flowers?.[1]) // 输出：undefined</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>Nullish Coalescing 空值合并。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let number = 0</span><br><span class="line">let myNumber = number ?? 7</span><br><span class="line">// 操作符右边的值仅在左边的值等于 null 或 undefined 时有效，因此，例子中的变量 myNumber 现在的值等于 0 了。</span><br></pre></td></tr></table></figure></li><li>Dynamic Import 动态引入<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Alert.js</span><br><span class="line">export default &#123;</span><br><span class="line">    show() &#123;</span><br><span class="line">        // 代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 使用 Alert.js 的文件</span><br><span class="line">import(&#x27;/components/Alert.js&#x27;)</span><br><span class="line">    .then(Alert =&gt; &#123;</span><br><span class="line">        Alert.show()</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></li><li>globalThis 全局对象: <code>JavaScript</code> 可以在不同环境中运行，比如浏览器或者 <code>Node.js</code>。浏览器中可用的全局对象是变量 <code>window</code>，但在 <code>Node.js</code> 中是一个叫做<code>global</code>的对象。为了在不同环境中都使用统一的全局对象，引入了 <code>globalThis</code> 。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 浏览器</span><br><span class="line">window == globalThis // true</span><br><span class="line"></span><br><span class="line">// node.js</span><br><span class="line">global == globalThis // true</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端基础知识 </category>
          
          <category> Js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 前端基础知识 </tag>
            
            <tag> ES8 </tag>
            
            <tag> ES9 </tag>
            
            <tag> ES10 </tag>
            
            <tag> ES11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试题--CSS篇(二)</title>
      <link href="/2021/08/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-CSS%E7%AF%87-%E4%BA%8C/"/>
      <url>/2021/08/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-CSS%E7%AF%87-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<H3> 清除浮动的方法 </H3><p>不清除浮动会发生高度塌陷：浮动元素父元素高度自适应（父元素不写高度时，子元素写了浮动后，父元素会发生高度塌陷）</p><ol><li><code>clear</code>清除浮动（添加空<code>div</code>法）在浮动元素下方添加空<code>div</code>,并给该元素写<code>css</code>样式：<code>&#123;clear:both;height:0;overflow:hidden;&#125;</code></li><li>给浮动元素父级设置高度</li><li>父级同时浮动（需要给父级同级元素添加浮动）</li><li>父级设置成<code>inline-block</code>，其<code>margin: 0 auto</code>居中方式失效</li><li>给父级添加<code>overflow:hidden</code> 清除浮动方法</li><li>万能清除法 <code>after</code>伪类清浮动（现在主流方法，推荐使用）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.float_div:after&#123;</span><br><span class="line">  content:&quot;.&quot;;</span><br><span class="line">  clear:both;</span><br><span class="line">  display:block;</span><br><span class="line">  height:0;</span><br><span class="line">  overflow:hidden;</span><br><span class="line">  visibility:hidden;</span><br><span class="line">&#125;</span><br><span class="line">.float_div&#123;</span><br><span class="line">  zoom:1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><H3> 弹性盒子中 flex: 0 1 auto 表示什么意思 </H3><p>三个参数分别对应的是 <code>flex-grow, flex-shrink</code> 和 <code>flex-basis</code>，默认值为<code>0 1 auto</code>。</p><ol><li>flex-grow：剩余空间索取：默认值为0，不索取<br>例：父元素<code>400p</code>x，子元素A为<code>100px</code>，B为<code>200px</code>。则剩余空间为<code>100</code>。此时A的<code>flex-grow</code> 为1，B为2，则<code>A=100px+100*1/3; B=200px+100*2/3</code></li><li>flex-shrink：子元素总宽度大于父，子元素如何缩小<br>例：父元素<code>400px</code>, 子元素A为<code>200px</code>，B为<code>300px</code>。AB总宽度超出父元素<code>100px</code>;<br>如果A不减少，则<code>flex-shrink ：0,</code>B减少；</li><li>flex-basis：该属性用来设置元素的宽度，当然<code>width</code>也可以用来设置元素的宽度，如果设置了<code>width</code>和<code>flex-basis</code>，那么<code>flex-basis</code>会覆盖<code>width</code>值。</li><li>举例如下<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//主轴空间宽度有剩余，子元素最终的宽度？</span><br><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;item-1&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item-2&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item-3&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    .parent &#123;</span><br><span class="line">        display: flex;</span><br><span class="line">        width: 600px;</span><br><span class="line">    &#125;</span><br><span class="line">    .parent &gt; div &#123;</span><br><span class="line">        height: 100px;</span><br><span class="line">    &#125;</span><br><span class="line">    .item-1 &#123;</span><br><span class="line">        width: 140px;</span><br><span class="line">        flex: 2 1 0%;</span><br><span class="line">        background: blue;</span><br><span class="line">    &#125;</span><br><span class="line">    .item-2 &#123;</span><br><span class="line">        width: 100px;</span><br><span class="line">        flex: 2 1 auto;</span><br><span class="line">        background: darkblue;</span><br><span class="line">    &#125;</span><br><span class="line">    .item-3 &#123;</span><br><span class="line">        flex: 1 1 200px;</span><br><span class="line">        background: lightblue;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">1、整体宽度为600px</span><br><span class="line">2、item-1的flex-basis设置了0%，所以宽度为0，item-2的flex-basis为auto，所以宽度为100px，item-3的flex-basis为200px，所以宽度为200px，还未伸缩的总宽度为300px</span><br><span class="line">3、剩余的宽度为600 - 300 = 300px</span><br><span class="line">4、放大的比例为 2 + 2 + 1 = 5</span><br><span class="line">5、所以item-1的宽度为 300 * 2 / 5 = 120px，item-2的宽度为 100 + （300 * 2 / 5）= 220px，item-3的宽度为 200 + （300 * 1 / 5）= 260px </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    .container &#123;</span><br><span class="line">      width: 600px;</span><br><span class="line">      height: 300px;</span><br><span class="line">      display: flex;</span><br><span class="line">    &#125;</span><br><span class="line">    .left &#123;</span><br><span class="line">      flex: 1 2 500px;  </span><br><span class="line">      background: red;</span><br><span class="line">    &#125;</span><br><span class="line">    .right &#123;</span><br><span class="line">      flex: 2 1 400px;</span><br><span class="line">      background: blue;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">1、整体宽度为600px</span><br><span class="line">2、left 的宽度为 500px，right的宽度为 400px，所以还未伸缩的总宽度为900px (&gt; 600px)</span><br><span class="line">3、需要收缩的宽度为900 - 600 = 300px</span><br><span class="line">4、总权重  500 * 2 + 400 * 1 = 1400</span><br><span class="line">5、left 需要缩小的宽度为 (500 * 2 / 1400) * 300 = 214.285714286px，right需要缩小的宽度为 (400 * 1 / 1400) * 300 = 85.714285714px，</span><br><span class="line">6、所以left 的宽度为 500 - 214.285714286 = 285.714285714px，right 的宽度为 400 - 85.714285714 = 314.285714286px</span><br></pre></td></tr></table></figure></li></ol><H3> 使用 CSS 实现三角形 </H3><ol><li>使用 <code>border</code> 绘制三角形：利用了高宽为零的容器及透明的 <code>border</code> 实现<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">  width: 0px;</span><br><span class="line">  height: 0px;</span><br><span class="line">  margin: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.normal &#123;</span><br><span class="line">   border-top: 50px solid yellowgreen;</span><br><span class="line">   border-bottom: 50px solid deeppink;</span><br><span class="line">   border-left: 50px solid bisque;</span><br><span class="line">   border-right: 50px solid chocolate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.top &#123;</span><br><span class="line">  border: 50px solid transparent;</span><br><span class="line">  border-bottom: 50px solid deeppink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.left &#123;</span><br><span class="line">  border: 50px solid transparent;</span><br><span class="line">  border-right: 50px solid deeppink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.bottom &#123;</span><br><span class="line">  border: 50px solid transparent;</span><br><span class="line">  border-top: 50px solid deeppink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.right &#123;</span><br><span class="line">  border: 50px solid transparent;</span><br><span class="line">  border-bottom: 50px solid deeppink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&#x27;normal&#x27;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&#x27;top&#x27;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&#x27;bottom&#x27;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&#x27;left&#x27;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&#x27;right&#x27;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li>使用 <code>linear-gradient</code> 绘制三角形：它的原理就是实现一个 <code>45°</code> 的渐变<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  margin: auto;</span><br><span class="line">&#125;</span><br><span class="line">.normal &#123;</span><br><span class="line">  background: linear-gradient(45deg, deeppink, yellowgreen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.gradient&#123;</span><br><span class="line">  background: linear-gradient(45deg, deeppink, deeppink 50%, yellowgreen 50%, yellowgreen 100%);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.rotate &#123;</span><br><span class="line">  background: linear-gradient(45deg, deeppink, deeppink 50%, transparent 50%, transparent 100%);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.top &#123;</span><br><span class="line">  background: linear-gradient(45deg, deeppink, deeppink 50%, transparent 50%, transparent 100%);</span><br><span class="line">  transform: rotate(135deg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.left &#123;</span><br><span class="line">  background: linear-gradient(45deg, deeppink, deeppink 50%, transparent 50%, transparent 1px);</span><br><span class="line">  transform: rotate(45deg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.bottom &#123;</span><br><span class="line">  background: linear-gradient(45deg, deeppink, deeppink 50%, transparent 50%, transparent 1px);</span><br><span class="line">  transform: rotate(-45deg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.right &#123;</span><br><span class="line">  background: linear-gradient(45deg, deeppink, deeppink 50%, transparent 50%, transparent 1px);</span><br><span class="line">  transform: rotate(-135deg);</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=&#x27;normal&#x27;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&#x27;top&#x27;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&#x27;bottom&#x27;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&#x27;left&#x27;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&#x27;right&#x27;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li>使用 <code>conic-gradient</code> 绘制三角形：角向渐变 <code>conic-gradient</code> 也可以用于实现三角形。方法在于，角向渐变的圆心点是可以设置的，我们将角向渐变的圆心点设置于 <code>50% 0</code>，也就是 <code>center top</code>，容器最上方的中间，再进行角向渐变，渐变到一定的角度范围内，都是三角形图形。<br>假设我们有一个 200px x 100px 高宽的容器，设置其角向渐变圆心点为 50% 0，并且，设置它从 90° 开始画角向渐变图，示意图如下：<br><img src="https://upload-images.jianshu.io/upload_images/17463653-c0aad5d27c295091.image?imageMogr2/auto-orient/strip"><br>可以看到，在初始的时候，角向渐变图形没有到第二条边的之前，都是三角形，我们选取适合的角度，非常容易的可以得到一个三角形：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin: auto;</span><br><span class="line">&#125;</span><br><span class="line">.normal &#123;</span><br><span class="line">    background: conic-gradient(from 90deg at 50% 0, deeppink 0, deeppink 45deg, transparent 45.1deg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.acute &#123;</span><br><span class="line">    background: conic-gradient(from 90deg at 50% 0, transparent 0, transparent 45deg, deeppink 45.1deg, deeppink 135deg, transparent 1deg);</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=&quot;normal&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;acute&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>上述代码中的  <code>deeppink 45deg, transparent 45.1deg</code> 多出来的 <code>0.1deg</code> 是为了简单消除渐变产生的锯齿的影响，这样，我们通过 <code>conic-gradient</code>，也轻松的得到了一个三角形。同理，再配合旋转 <code>rotate</code> 或者 <code>scale</code>，我们也能得到各种角度，不同大小的三角形。</li><li>transform: rotate 配合 overflow: hidden 绘制三角形<br>设置图形的旋转中心在左下角 <code>left bottom</code>，进行旋转，配合 <code>overflow: hidden</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.triangle &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    background: unset;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    </span><br><span class="line">    &amp;::before &#123;</span><br><span class="line">        content: &quot;&quot;;</span><br><span class="line">        position: absolute;</span><br><span class="line">        top: 0;</span><br><span class="line">        left: 0;</span><br><span class="line">        right: 0;</span><br><span class="line">        bottom: 0;</span><br><span class="line">        background: deeppink;</span><br><span class="line">        transform-origin: left bottom;</span><br><span class="line">        transform: rotate(45deg);</span><br><span class="line">        z-index: -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=&quot;triangle&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li>使用 <code>clip-path</code> 绘制三角形：<code>clip-path CSS</code> 属性可以将一个容器裁剪成任何我们想要的样子，通过 3 个坐标点，实现一个多边形，多余的空间则会被裁减掉<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin: auto;</span><br><span class="line">&#125;</span><br><span class="line">.triangle &#123;</span><br><span class="line">    background: deeppink;</span><br><span class="line">    clip-path: polygon(0 0, 100% 0, 0 100%, 0 0);</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=&quot;triangle&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li>利用字符绘制三角形<br>下面列出一些三角形形状的字符的十进制 <code>Unicode</code> 表示码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">◄ : &amp;#9668; </span><br><span class="line">► : &amp;#9658; </span><br><span class="line">▼ : &amp;#9660; </span><br><span class="line">▲ : &amp;#9650;</span><br><span class="line">⊿ : &amp;#8895;</span><br><span class="line">△ : &amp;#9651;</span><br></pre></td></tr></table></figure>我们使用 <code>&amp;#9660</code>; 实现一个三角形 ▼，代码如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@import url(&#x27;https://fonts.googleapis.com/css2?family=Dancing+Script&amp;family=Dela+Gothic+One&amp;family=New+Tegomin&amp;family=Train+One&amp;family=ZCOOL+QingKe+HuangYou&amp;display=swap&#x27;);</span><br><span class="line">div &#123;</span><br><span class="line">    font-size: 100px;</span><br><span class="line">    color: deeppink;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=&quot;normal&quot;&gt;&amp;#9660; &lt;/div&gt;</span><br></pre></td></tr></table></figure>需要注意的是，使用字符表示三角形与当前设定的字体是强相关的，不同的字体绘制出的同一个字符是不一样的，所以如果你想使用字符三角形，确保用户的浏览器安装了你指定的字体，否则，不要使用这种方式</li></ol><H3> 纯 CSS 实现霓虹灯光 </H3><p>要实现的效果：在鼠标移入按钮的时候，会产生类似霓虹灯光的效果；在鼠标移出按钮的时候，会有一束光沿着固定的轨迹（按钮外围）运动，如下图：<br><img src="https://upload-images.jianshu.io/upload_images/17463653-103dad53dda81b0b.gif?imageMogr2/auto-orient/strip"></p><ol><li>霓虹灯光的实现：霓虹灯光的实现可以用多重阴影来做。给按钮加三层阴影，从内到外每层阴影的模糊半径递增，这样多个阴影叠加在一起，就可以形成一个类似霓虹灯光的效果。代码如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line"> background: #050901;   </span><br><span class="line">&#125;</span><br><span class="line">.light &#123;</span><br><span class="line">  width: fit-content;</span><br><span class="line">  padding: 25px 30px;</span><br><span class="line">  color: #03e9f4;</span><br><span class="line">  font-size: 24px;</span><br><span class="line">  text-transform: uppercase;</span><br><span class="line">  transition: 0.5s;</span><br><span class="line">  letter-spacing: 4px;</span><br><span class="line">  cursor: pointer;</span><br><span class="line">&#125;</span><br><span class="line">.light:hover &#123;</span><br><span class="line">  background-color: #03e9f4;</span><br><span class="line">  color: #050801;</span><br><span class="line">  box-shadow: 0 0 5px #03e9f4,</span><br><span class="line">              0 0 25px #03e9f4,</span><br><span class="line">              0 0 50px #03e9f4,</span><br><span class="line">              0 0 200px #03e9f4;</span><br><span class="line">&#125;</span><br><span class="line"> &lt;div class=&quot;light&quot;&gt;</span><br><span class="line">    Neon Button</span><br><span class="line"> &lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li>运动光束的实现：虽然看起来只有一个光束沿着按钮的边缘运动，但实际上这是四个光束沿着不同方向运动之后叠加的效果。它们运动的方向分别是：从左往右、从上往下、从右往左、从下往上。<ul><li>四个光束分别对应 <code>div.light</code> 的四个子 <code>div</code>，初始位置分别是在按钮的最左侧、最上方、最右侧和最下方，并按照固定的方向做重复的运动</li><li>每个光束的高度或宽度都很小（只有 2px），并且都有一个从透明色到霓虹色的渐变，因此外表会有一个收束的效果（即看上去不是一条完整的线条）</li><li>为了确保我们看到的是一个顺时针方向的运动，四个光束的运动实际上是有序的，首先是按钮上方的光束开始运动，在一段时间后，右侧的光束运动，在一段时间后，下方的光束运动，在一段时间后，左侧的光束运动。光束和光束之间的运动有一个延迟，以上方和右侧的光束为例，如果它们同时开始运动，由于右侧的运动距离小于上方的运动距离，就会导致这两个光束错过相交的时机，我们看到的就会是断开的、不连贯的光束。既然右侧光束的运动距离比较短，为了让上方光束可以“追上”它，我们就得让右侧光束“延迟出发”，因此要给它一个动画延迟；同理，剩余两个光束也要有一个动画延迟。多个动画延迟之间大概相差 0.25 秒即可。</li><li>只需要显示按钮边缘的光束就够了，因此给 <code>div.light</code> 设置一个溢出隐藏<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.light &#123;</span><br><span class="line">position: relative;</span><br><span class="line">padding: 25px 30px;</span><br><span class="line">color: #03e9f4;</span><br><span class="line">font-size: 24px;</span><br><span class="line">text-transform: uppercase;</span><br><span class="line">transition: 0.5s;</span><br><span class="line">letter-spacing: 4px;</span><br><span class="line">cursor: pointer;</span><br><span class="line">overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">.light:hover &#123;</span><br><span class="line">background-color: #03e9f4;</span><br><span class="line">color: #050801;</span><br><span class="line">box-shadow: 0 0 5px #03e9f4,</span><br><span class="line">            0 0 25px #03e9f4,</span><br><span class="line">            0 0 50px #03e9f4,</span><br><span class="line">            0 0 200px #03e9f4;</span><br><span class="line">&#125;</span><br><span class="line">.light div &#123;</span><br><span class="line">position: absolute;</span><br><span class="line">&#125;</span><br><span class="line">.light div:nth-child(1)&#123;</span><br><span class="line">width: 100%;</span><br><span class="line">height: 2px;</span><br><span class="line">top: 0;</span><br><span class="line">left: -100%;</span><br><span class="line">background: linear-gradient(to right,transparent,#03e9f4);</span><br><span class="line">animation: animate1 1s linear infinite;</span><br><span class="line">&#125;</span><br><span class="line">.light div:nth-child(2)&#123;</span><br><span class="line">width: 2px;</span><br><span class="line">height: 100%;</span><br><span class="line">top: -100%;</span><br><span class="line">right: 0;</span><br><span class="line">background: linear-gradient(to bottom,transparent,#03e9f4);</span><br><span class="line">animation: animate2 1s linear infinite;</span><br><span class="line">animation-delay: 0.25s;</span><br><span class="line">&#125;</span><br><span class="line">.light div:nth-child(3)&#123;</span><br><span class="line">width: 100%;</span><br><span class="line">height: 2px;</span><br><span class="line">bottom: 0;</span><br><span class="line">right: -100%;</span><br><span class="line">background: linear-gradient(to left,transparent,#03e9f4);</span><br><span class="line">animation: animate3 1s linear infinite;</span><br><span class="line">animation-delay: 0.5s;</span><br><span class="line">&#125;</span><br><span class="line">.light div:nth-child(4)&#123;</span><br><span class="line">width: 2px;</span><br><span class="line">height: 100%;</span><br><span class="line">bottom: -100%;</span><br><span class="line">left: 0;</span><br><span class="line">background: linear-gradient(to top,transparent,#03e9f4);</span><br><span class="line">animation: animate4 1s linear infinite;</span><br><span class="line">animation-delay: 0.75s;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes animate1 &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">    left: -100%;</span><br><span class="line">&#125;</span><br><span class="line">50%,100% &#123;</span><br><span class="line">    left: 100%;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes animate2 &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">    top: -100%;</span><br><span class="line">&#125;</span><br><span class="line">50%,100% &#123;</span><br><span class="line">    top: 100%;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes animate3 &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">    right: -100%;</span><br><span class="line">&#125;</span><br><span class="line">50%,100% &#123;</span><br><span class="line">    right: 100%;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes animate4 &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">    bottom: -100%;</span><br><span class="line">&#125;</span><br><span class="line">50%,100% &#123;</span><br><span class="line">    bottom: 100%;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;light&quot;&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    Neon Button</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端面试题 </category>
          
          <category> CSS篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 前端基础知识 </tag>
            
            <tag> CSS </tag>
            
            <tag> CSS3 </tag>
            
            <tag> flex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack简介</title>
      <link href="/2021/08/02/webpack%E7%AE%80%E4%BB%8B/"/>
      <url>/2021/08/02/webpack%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<H3> 简介 </H3><p><code>webpack</code> 是一个现代 <code>JavaScript</code> 应用程序的静态模块打包器(<code>module bundler</code>)。主要是用来将前端资源打包、压缩、优化。</p><ol><li>webpack 打包原理<br>当 <code>webpack</code> 处理应用程序时，不会根据 <code>package.json</code> 文件中的<code>devDependencies</code> 或者 <code>Dependencies</code> 的内容对文件进行打包。而是会根据入口文件做查询，加载其所依赖的包模块，它会递归地构建一个依赖关系图<code>(dependency graph)</code>，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 <code>bundle</code>。</li><li>两个最核心的概念 <ul><li>一切皆模块<br>正如<code>js</code>文件可以是一个模块<code>（module）</code>一样，其他的（如<code>css</code>、<code>image</code>或<code>html</code>）文件也可视作模块。因此，你可以<code>require(‘myJSfile.js’)</code>也可以<code>require(‘myCSSfile.css’)</code>。这意味着我们可以把业务分割成更小的易于管理的片段，从而达到重复利用的目的。</li><li>按需加载<br>传统的模块打包工具<code>（module bundlers）</code>最终将所有的模块编译生成一个庞大的<code>bundle.js</code>文件。但是在真实的<code>app</code>里边，<code>bundle.js</code>文件可能有<code>10M</code>到<code>15M</code>之大，可能会导致应用一直处于加载中状态。因此<code>Webpack</code>使用许多特性来分割代码然后生成多个<code>bundle</code>文件，而且异步加载部分代码以实现按需加载。</li></ul></li></ol><H3> 安装 </H3><p><code>webpack</code>支持使用<code>npm</code> 或者 <code>yarn</code> 方式进行安装。不推荐全局安装 <code>webpack</code>，这会将你项目中的 <code>webpack</code> 锁定到指定版本，并且在使用不同的 <code>webpack</code> 版本的项目中，可能会导致构建失败。本地安装可以使我们更容易对不同的项目进行分别升级。通常，<code>webpack</code> 通过运行一个或多个 <code>npm scripts</code>，会在本地 <code>node_modules</code> 目录中查找安装的 <code>webpack</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;webpack&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用 <code>webpack 4+ </code>版本，还需要安装 <code>CLI</code>。<code>webpack-cli</code> 可以允许直接在控制台操作<code>webpack</code>命令。终端中输入 <code>webpack --help</code>，可以查看所有的帮助信息。</p><ul><li>使用npm安装<br><code>npm install webpack webpack-cli --save-dev</code></li><li>使用yarn安装<br><code>yarn add webpack webpack-cli -D</code></li></ul><H3> webpack基本概念 </H3><p>以以下目录结构为例来了解以下<code>webpack</code>的基本概念</p><p><img src="https://upload-images.jianshu.io/upload_images/17463653-e22056571835dbb6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><ol><li>入口 entry：在<code>webpack.config.js</code>配置文件中，通过设置<code>entry</code>字段的值，指定一个入口起点（或多个入口起点），不配置的话，默认入口起点为<code>src</code>目录下的<code>index.js</code>模块。<ul><li>默认值为<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#x27;./src&#x27;</span><br><span class="line">    //相当于</span><br><span class="line">    entry:&#123; main:&quot;/src/index.js&quot; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>单页面配置<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#x27;./path/to/my/entry/file.js&#x27;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>多页面配置<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">    &#x27;main&#x27;: &quot;./src/js/index.js&quot;,</span><br><span class="line">    &#x27;detail&#x27;: &quot;./src/js/detai.js&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li>输出output ：<code>output</code> 属性告诉 <code>webpack</code> 在哪里输出它所创建的 <code>bundles</code>，以及如何命名这些文件，默认值为 <code>./dist</code>。基本上，整个应用程序结构，都会被编译到指定的输出路径的文件夹中。可以通过在配置中指定一个 <code>output</code> 字段，来配置这些处理过程。<ul><li>默认值为<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    output: &#123;</span><br><span class="line">        //path需要为绝对路径</span><br><span class="line">    path: path.resolve(__dirname, &#x27;./dist&#x27;),</span><br><span class="line">    filename: &#x27;main.js&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>自定义配置：<code>output</code> 的 <code>filename</code>属性中，使用<code>[name]</code>来表示<code>entry</code>中的<code>key</code>；使用<code>[hash]</code>，会自动在文件名称后面添加<code>hash</code>值，并直接关联到<code>html</code>模板文件中。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        &#x27;main&#x27;: &quot;./src/js/index.js&quot;,</span><br><span class="line">        &#x27;detail&#x27;: &quot;./src/js/detai.js&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &#x27;./dev&#x27;),</span><br><span class="line">        filename: &#x27;[name]-[hash].js&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li>loader：<code>loader</code> 让 <code>webpack</code> 能够去处理那些非 <code>JavaScript</code> 文件（<code>webpack</code> 自身只理解 <code>JavaScript</code>）。简单来说，<code>loader</code> 就是一个翻译官，将浏览器不认识的语言，转化为浏览器能解析的语言，<code>loader</code>使用之前需要先安装。<code>loader</code> 能够 <code>import</code> 导入任何类型的模块（例如 <code>.scss </code>文件），这是 <code>webpack</code> 特有的功能，其他打包程序或任务执行器的可能并不支持。<ul><li>webpack.config.js文件<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">    &#123;</span><br><span class="line">        test: /\.s[ac]ss$/,</span><br><span class="line">        //当 use 里有多个loader时，执行的顺序为从右向左</span><br><span class="line">        use: [</span><br><span class="line">        // 将 JS 字符串生成为 style 节点，插入html中，生成内联样式</span><br><span class="line">        &#x27;style-loader&#x27;,</span><br><span class="line">        //将 CSS 转化成 CommonJS 模块，可以直接使用import/require导入</span><br><span class="line">        &#x27;css-loader&#x27;,</span><br><span class="line">        //把.scss文件文件转换为.css文件</span><br><span class="line">        &#x27;sass-loader&#x27;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>在<code>webpack.config.js</code>文件中，对一个单独的 <code>module</code> 对象定义了 <code>rules</code> 属性，里面包含两个必须属性：<code>test</code> 和 <code>use</code>。这告诉 <code>webpack</code> 编译器<code>(compiler)</code> 如下信息：当编译器碰到「在 <code>require()/import</code> 语句中被解析为 <code>‘.sass/.scss’</code> 的路径」时，在对它打包之前，先使用 <code>sass-loader、css-loader、style-loader</code> 转换一下。最终<code>.scss</code>文件会被转成内联样式，插入<code>html</code>页面中。</li></ul></li><li>plugins 插件：<code>loader</code> 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务，插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。想要使用一个插件，只需要 <code>require()</code> 它，然后把它添加到 <code>plugins</code> 数组中。多数插件可以通过选项<code>(option)</code>自定义，也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 <code>new</code> 操作符来创建它的一个实例。<ul><li>webpack.config.js文件<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//html-webpack-plugin 将html模板文件和js文件整合到一起</span><br><span class="line">const htmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            //模板文件路径</span><br><span class="line">            template: &quot;./src/views/index.html&quot;,</span><br><span class="line">            //自动存储到output 配置的目录</span><br><span class="line">            filename: &#x27;index.html&#x27;,</span><br><span class="line">            chunks: [&#x27;main&#x27;]</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><code>html-webpack-plugin</code> 插件的作用是将<code>html</code>模板文件和<code>js</code>文件整合到一起，如果是多页面应用，则每个页面都需要有对应的<code>new HtmlWebpackPlugin()</code>。<code>webpack</code>在编译的时候，会把所有的 <code>js </code>合并输出在一个<code>js</code>文件，而设置 <code>chunks</code> 属性的目的，就是让当前页面模板只加载当前页面所需要的模块。上面的写法表示，在编译<code>./src/views/index.html</code> 时，只需要加载<code>main.js</code>文件。</li></ul></li></ol><H3> webpack配置 </H3><ol><li>mode 模式<br><code>mode </code>配置选项，告知<code> webpack</code> 使用相应模式的内置优化。有两个值：<code>development</code>（开发模式不会对代码做压缩、优化，方便代码调试，会将 <code>process.env.NODE_ENV</code> 的值设为 <code>development</code>）和<code>production</code>（生产模式下会对代码做压缩、优化，会将 <code>process.env.NODE_ENV</code> 的值设为 <code>production</code>）。如果不配置<code>mode</code>，会有警告信息，但是不影响项目运行。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">mode:&quot;development&quot;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>devtool<br>开发模式通常配合<code>devtool</code>使用，可以在浏览器的控制台看到源代码，而不是解析后的代码。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">//代码调试，可以看到源代码</span><br><span class="line">devtool: &#x27;inline-source-map&#x27;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>webpack-dev-server<br>在开发模式下，新建一个开发服务器，并且当代码更新的时候自动刷新浏览器。可以使用<code>webpack-dev-server</code>插件。直接使用<code>webpack</code>执行，会对文件进行打包，并输出在指定目录下，默认为<code>./dev</code>下。使用<code>webpack-dev-server</code>执行，文件会放在内存里，不会生成整合后的文件，也不会将文件输出到指定目录里。<br>在<code>webpack.config.js</code>文件中配置<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">devServer:&#123;</span><br><span class="line">    contentBase:&quot;./dist&quot;, //设置Http服务器的文件根目录</span><br><span class="line">    port:8088, //端口</span><br><span class="line">    open:true, //是否打开浏览器</span><br><span class="line">    proxy: &#123; //配置代理</span><br><span class="line">  &quot;/api&quot;: &#123;</span><br><span class="line">    target: &quot;http://localhost:3000&quot;,</span><br><span class="line">    pathRewrite: &#123;&quot;^/api&quot; : &quot;&quot;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>webpack.config.js<br>一个开发模式下，完整的<code>webpack.config.js</code>文件内容如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const path=require(&quot;path&quot;);</span><br><span class="line">//将html模板和js文件整合在一起</span><br><span class="line">const htmlWebpackPlugin=require(&quot;html-webpack-plugin&quot;);</span><br><span class="line">//将css样式提取出来，使用Link标签导入</span><br><span class="line">const miniCssExtractPlugin=require(&quot;mini-css-extract-plugin&quot;);</span><br><span class="line">//将静态资源打包到输出目录中</span><br><span class="line">const copyWebpackPlugin=require(&quot;copy-webpack-plugin&quot;);</span><br><span class="line"></span><br><span class="line">module.exports=&#123;</span><br><span class="line">    mode:&quot;development&quot;,</span><br><span class="line">    devtool:&quot;inline-source-map&quot;,</span><br><span class="line">    entry:&quot;./src/js/index.js&quot;,</span><br><span class="line">    output:&#123;</span><br><span class="line">        path:path.resolve(__dirname+&quot;./dev&quot;),</span><br><span class="line">        filename:&quot;[name]-[hash].js&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    devServer:&#123;</span><br><span class="line">        port:8088,</span><br><span class="line">        open:true,</span><br><span class="line">        proxy: &#123; //配置代理</span><br><span class="line">  &quot;/api&quot;: &#123;</span><br><span class="line">    target: &quot;http://localhost:3000&quot;,</span><br><span class="line">    pathRewrite: &#123;&quot;^/api&quot; : &quot;&quot;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:[</span><br><span class="line">        new htmlWebpackPlugin(&#123;</span><br><span class="line">            title:&quot;demo title&quot;,</span><br><span class="line">            template:&quot;./src/views/index.html&quot;,</span><br><span class="line">            filename:&quot;index.html&quot;,</span><br><span class="line">            chunks:[&quot;main&quot;]</span><br><span class="line">        &#125;),</span><br><span class="line">        new miniCssExtractPlugin(&#123;</span><br><span class="line">            filename:&quot;[name]-[hash].css&quot;</span><br><span class="line">        &#125;),</span><br><span class="line">        new copyWebpackPlugin([</span><br><span class="line">            &#123;from:&quot;./src/static&quot;,to:&quot;./static&quot;&#125;</span><br><span class="line">        ])</span><br><span class="line">    ],</span><br><span class="line">    module:&#123;</span><br><span class="line">        rules:[</span><br><span class="line">            &#123;</span><br><span class="line">                test:/\.s[ac]ss$/,</span><br><span class="line">                use:[</span><br><span class="line">                    miniCssExtractPlugin.loader,</span><br><span class="line">                    &quot;css-loader&quot;,</span><br><span class="line">                    &quot;sass-loader&quot;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,        </span><br><span class="line">            &#123;</span><br><span class="line">                test:/\.html$/,</span><br><span class="line">                use:[&quot;string-loader&quot;]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><code>package.json</code>文件内容如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;admin-fe&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;webpack-dev-server --config webpack.config.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [],</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;handlebars&quot;: &quot;^4.7.3&quot;,</span><br><span class="line">    &quot;sme-router&quot;: &quot;^0.12.8&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;copy-webpack-plugin&quot;: &quot;^5.1.1&quot;,</span><br><span class="line">    &quot;css-loader&quot;: &quot;^3.4.2&quot;,</span><br><span class="line">    &quot;html-webpack-plugin&quot;: &quot;^4.0.1&quot;,</span><br><span class="line">    &quot;mini-css-extract-plugin&quot;: &quot;^0.9.0&quot;,</span><br><span class="line">    &quot;node-sass&quot;: &quot;^4.13.1&quot;,</span><br><span class="line">    &quot;sass-loader&quot;: &quot;^8.0.2&quot;,</span><br><span class="line">    &quot;string-loader&quot;: &quot;^0.0.1&quot;,</span><br><span class="line">    &quot;style-loader&quot;: &quot;^1.1.3&quot;,</span><br><span class="line">    &quot;webpack&quot;: &quot;^4.42.1&quot;,</span><br><span class="line">    &quot;webpack-cli&quot;: &quot;^3.3.11&quot;,</span><br><span class="line">    &quot;webpack-dev-server&quot;: &quot;^3.10.3&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><H3> webpack优势 </H3><p>与其他的构建工具相比，webpack具有如下的一些优势：</p><ul><li>对 CommonJS 、 AMD 、ES6 的语法做了兼容</li><li>对 js、css、图片等资源文件都支持打包</li><li>串联式模块加载器以及插件机制，让其具有更好的灵活性和扩展性，例如提供对 CoffeeScript、ES6的支持</li><li>有独立的配置文件 webpack.config.js</li><li>可以将代码切割成不同的 chunk，实现按需加载，降低了初始化时间</li><li>支持 SourceUrls 和 SourceMaps，易于调试</li><li>具有强大的 Plugin 接口，大多是内部插件，使用起来比较灵活</li><li>webpack 使用异步 IO 并具有多级缓存，这使得 webpack 很快且在增量编译上更加快</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端基础知识 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 工程化 </tag>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm模块安装机制简介</title>
      <link href="/2021/07/30/npm%E6%A8%A1%E5%9D%97%E5%AE%89%E8%A3%85%E6%9C%BA%E5%88%B6%E7%AE%80%E4%BB%8B/"/>
      <url>/2021/07/30/npm%E6%A8%A1%E5%9D%97%E5%AE%89%E8%A3%85%E6%9C%BA%E5%88%B6%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<H3> npm 模块安装机制 </H3><ol><li>发出<code>npm instal</code>l命令</li><li>查询<code>node_modules</code>目录之中是否已经存在指定模块。若存在，不再重新安装；若不存在，执行以下步骤：<ul><li><code>npm</code> 向 <code>registry</code> 查询模块压缩包的网址</li><li>下载压缩包，存放在根目录下的<code>.npm</code>目录里</li><li>解压压缩包到当前项目的<code>node_modules</code>目录</li></ul></li></ol><H3> npm 实现原理 </H3><p>输入 <code>npm install</code> 命令并敲下回车后，会经历如下几个阶段（以 npm 5.5.1 为例）：</p><ol><li><p>执行工程自身 preinstall<br>当前 <code>npm</code> 工程如果定义了 <code>preinstall</code> 钩子此时会被执行。</p></li><li><p>确定首层依赖模块</p><ul><li>首先需要做的是确定工程中的首层依赖，也就是 <code>dependencies</code> 和 <code>devDependencies</code> 属性中直接指定的模块（假设此时没有添加 <code>npm install</code> 参数）。</li><li>工程本身是整棵依赖树的根节点，每个首层依赖模块都是根节点下面的一棵子树，<code>npm</code> 会开启多进程从每个首层依赖模块开始逐步寻找更深层级的节点。</li></ul></li><li><p>获取模块<br>获取模块是一个递归的过程，分为以下几步</p><ul><li>获取模块信息。在下载一个模块之前，首先要确定其版本，这是因为 <code>package.json </code>中往往是 <code>semantic version</code>（<code>semver</code>，语义化版本）。此时如果版本描述文件<code>（npm-shrinkwrap.json 或 package-lock.json）</code>中有该模块信息直接拿即可，如果没有则从仓库获取。如 <code>packaeg.json</code> 中某个包的版本是<code> ^1.1.0</code>，<code>npm </code>就会去仓库中获取符合 <code>1.x.x</code> 形式的最新版本。</li><li>获取模块实体。上一步会获取到模块的压缩包地址（<code>resolved</code> 字段），<code>npm</code> 会用此地址检查本地缓存，缓存中有就直接拿，如果没有则从仓库下载。</li><li>查找该模块依赖，如果有依赖则回到第1步，如果没有则停止。</li></ul></li><li><p>模块扁平化（dedupe）<br>上一步获取到的是一棵完整的依赖树，其中可能包含大量重复模块。比如 <code>A</code> 模块依赖于 <code>loadsh</code>，<code>B</code> 模块同样依赖于 <code>lodash</code>。在 <code>npm3</code> 以前会严格按照依赖树的结构进行安装，因此会造成模块冗余。<br>从 <code>npm3</code> 开始默认加入了一个 <code>dedupe</code> 的过程。它会遍历所有节点，逐个将模块放在根节点下面，也就是 <code>node-modules</code> 的第一层。当发现有重复模块时，则将其丢弃。<br>这里需要对重复模块进行一个定义，它指的是模块名相同且 <code>semver</code> 兼容。每个 <code>semver</code> 都对应一段版本允许范围，如果两个模块的版本允许范围存在交集，那么就可以得到一个兼容版本，而不必版本号完全一致，这可以使更多冗余模块在 <code>dedupe</code> 过程中被去掉。<br>比如 <code>node-modules</code> 下 <code>foo</code> 模块依赖 <code>lodash@^1.0.0</code>，<code>bar</code> 模块依赖 <code>lodash@^1.1.0</code>，则 <code>^1.1.0</code> 为兼容版本。<br>而当 <code>foo</code> 依赖 <code>lodash@^2.0.0</code>，<code>bar</code> 依赖 <code>lodash@^1.1.0</code>，则依据 <code>semver</code> 的规则，二者不存在兼容版本。会将一个版本放在 <code>node_modules</code> 中，另一个仍保留在依赖树里。<br>举个例子，假设一个依赖树原本是这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node_modules</span><br><span class="line">-- foo</span><br><span class="line">---- lodash@version1</span><br><span class="line"></span><br><span class="line">-- bar</span><br><span class="line">---- lodash@version2</span><br><span class="line"></span><br><span class="line">假设 version1 和 version2 是兼容版本，则经过 dedupe 会成为下面的形式：</span><br><span class="line"></span><br><span class="line">node_modules</span><br><span class="line">-- foo</span><br><span class="line"></span><br><span class="line">-- bar</span><br><span class="line"></span><br><span class="line">-- lodash（保留的版本为兼容版本）</span><br><span class="line"></span><br><span class="line">假设 version1 和 version2 为非兼容版本，则后面的版本保留在依赖树中：</span><br><span class="line"></span><br><span class="line">node_modules</span><br><span class="line">-- foo</span><br><span class="line">-- lodash@version1</span><br><span class="line"></span><br><span class="line">-- bar</span><br><span class="line">---- lodash@version2</span><br></pre></td></tr></table></figure></li><li><p>安装模块<br>这一步将会更新工程中的 <code>node_modules</code>，并执行模块中的生命周期函数（按照 <code>preinstall、install、postinstall</code> 的顺序）。</p></li><li><p>执行工程自身生命周期<br>当前 <code>npm </code>工程如果定义了钩子此时会被执行（按照 <code>install、postinstall、prepublish、prepare</code> 的顺序）。<br>最后一步是生成或更新版本描述文件，<code>npm install</code> 过程完成。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端基础知识 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 模块化 </tag>
            
            <tag> 工程化 </tag>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6、ES7常用特性</title>
      <link href="/2021/07/30/ES6%E3%80%81ES7%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7/"/>
      <url>/2021/07/30/ES6%E3%80%81ES7%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<H3> ES6(ES2015)新特性 </H3><ol><li><p>支持let和const<br>在之前JS是没有块级作用域的，<code>const</code>与<code>let</code>填补了这方便的空白，<code>const</code>与<code>let</code>都是块级作用域。</p><ul><li>使用<code>var</code>定义的变量为函数级作用域<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">var a = 10;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a); // 输出10</span><br></pre></td></tr></table></figure></li><li>使用<code>let</code>定义的变量为块级作用域<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">let a = 10;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a); //Uncaught ReferenceError: a is not defined</span><br></pre></td></tr></table></figure></li></ul></li><li><p>箭头函数<br><code>=&gt;</code>不只是关键字<code>function的</code>简写，箭头函数与包围它的代码共享同一个<code>this</code>，能很好的解决<code>this</code>的指向问题。</p><ul><li>箭头函数的结构：箭头函数的箭头<code>=&gt;</code>之前是一个空括号、单个的参数名、或用括号括起的多个参数名，而箭头之后可以是一个表达式（作为函数的返回值），或者是用花括号括起的函数体（需要自行通过<code>return</code>来返回值，否则返回的是<code>undefined</code>）。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ES5</span><br><span class="line">var mul = function(x, y) &#123;</span><br><span class="line">return x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ES6</span><br><span class="line">const mul = (x, y) =&gt; x * y;</span><br><span class="line">// 或者</span><br><span class="line">const mul = (x, y) =&gt; &#123; return x * y &#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>类（class）<br><code>ES6</code> 的<code>class</code>可以看作只是一个语法糖，它的绝大部分功能，<code>ES5</code>都可以做到，新的<code>class</code>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p><ul><li><code>constructor</code>方法是类的默认方法，通过<code>new</code>命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor</code>方法，如果没有显式定义，一个空的<code>constructor</code>方法会被默认添加。类必须使用<code>new</code>调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用<code>new</code>也可以执行。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Car &#123;</span><br><span class="line">constructor(brand) &#123;</span><br><span class="line">    this.carName = brand;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let myCar = new Car(&quot;Ford&quot;);</span><br><span class="line">console.log(myCar); // Car &#123;carName: &quot;Ford&quot;&#125;</span><br></pre></td></tr></table></figure></li><li>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">static classMethod() &#123;</span><br><span class="line">    return &#x27;hello&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.classMethod() // &#x27;hello&#x27;</span><br><span class="line"></span><br><span class="line">var foo = new Foo();</span><br><span class="line">foo.classMethod()</span><br><span class="line">// TypeError: foo.classMethod is not a function</span><br></pre></td></tr></table></figure></li></ul></li><li><p>函数参数默认值<br><code>ES6</code>支持在定义函数的时候为其设置默认值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function myFunction(x, y = 10) &#123;</span><br><span class="line">  // y is 10 if not passed or undefined</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line">myFunction(5); // 15</span><br></pre></td></tr></table></figure></li><li><p>模块化 module<br><code>ES6</code>的模块自动采用严格模式，不管你有没有在模块头部加上<code>&quot;use strict&quot;</code>;。</p><ul><li><p>严格模式主要有以下限制：</p><ul><li>变量必须声明后再使用</li><li>函数的参数不能有同名属性，否则报错</li><li>不能使用with语句</li><li>不能对只读属性赋值，否则报错</li><li>不能使用前缀 0 表示八进制数，否则报错</li><li>不能删除不可删除的属性，否则报错</li><li>不能删除变量<code>delete prop</code>，会报错，只能删除属性<code>delete global[prop]</code></li><li><code>eval</code>不会在它的外层作用域引入变量</li><li><code>eval</code>和<code>arguments</code>不能被重新赋值</li><li><code>arguments</code>不会自动反映函数参数的变化</li><li>不能使用<code>arguments.callee</code></li><li>不能使用<code>arguments.caller</code></li><li>禁止<code>this</code>指向全局对象</li><li>不能使用<code>fn.caller</code>和<code>fn.arguments</code>获取函数调用的堆栈</li><li>增加了保留字（比如<code>protected、static和interface</code>）</li></ul></li><li><p>模块功能主要由两个命令构成：<code>export和import</code>。<code>export</code>命令用于规定模块的对外接口，<code>import</code>命令用于输入其他模块提供的功能。</p><ul><li>export<br>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量。下面是一个<code>JS</code>文件，里面使用<code>export</code>命令输出变量<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//一、 输出变量</span><br><span class="line">export var year = 2020;</span><br><span class="line">// 或者</span><br><span class="line">var year = 2020;</span><br><span class="line">export &#123; year &#125;;</span><br><span class="line"></span><br><span class="line">//二、输出函数或类（class）</span><br><span class="line">export function multiply(x, y) &#123;</span><br><span class="line">return x * y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//或者使用as关键字，重命名函数v1和v2的对外接口。重命名后，v2可以用不同的名字输出两次</span><br><span class="line">function v1() &#123; ... &#125;</span><br><span class="line">function v2() &#123; ... &#125;</span><br><span class="line">export &#123;</span><br><span class="line">v1 as streamV1,</span><br><span class="line">v2 as streamV2,</span><br><span class="line">v2 as streamLatestVersion</span><br><span class="line">&#125;;</span><br><span class="line">// 三、输出默认</span><br><span class="line">export default function foo() &#123;</span><br><span class="line">console.log(&#x27;foo&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>import<br>使用<code>export</code>命令定义了模块的对外接口以后，其他<code>JS</code>文件就可以通过<code>import</code>命令加载这个模块。<code>import</code>后面的<code>from</code>指定模块文件的位置，可以是相对路径，也可以是绝对路径。如果不带有路径，只是一个模块名，那么必须有配置文件，告诉<code>JavaScript</code>引擎该模块的位置。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 一、输入变量</span><br><span class="line">import &#123; firstName, lastName, year &#125; from &#x27;./profile.js&#x27;;</span><br><span class="line">// 使用as关键字，将输入的变量重命名。</span><br><span class="line">import &#123; lastName as surname &#125; from &#x27;./profile.js&#x27;;</span><br><span class="line">// 二、整体加载</span><br><span class="line">import * as circle from &#x27;./circle&#x27;;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>模版字符串<br><code>ES6</code>支持模板字符串，使得字符串的拼接更加的简洁、直观。在<code>ES6</code>中通过<code>$&#123;&#125;</code>就可以完成字符串的拼接，只需要将变量放在大括号之中。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//不使用模板字符串：</span><br><span class="line">var name = &#x27;Your name is &#x27; + first + &#x27; &#x27; + last + &#x27;.&#x27;</span><br><span class="line"> </span><br><span class="line">//使用模板字符串：</span><br><span class="line">var name = `Your name is $&#123;first&#125; $&#123;last&#125;.`</span><br></pre></td></tr></table></figure></li><li><p>解构赋值<br><code>ES6</code>允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构<code>（Destructuring）</code>。事实上，只要某种数据结构具有<code>Iterator</code>接口，都可以采用数组形式的解构赋值。</p><ul><li>数组的解构赋值<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let [a, b, c] = [1, 2, 3];</span><br><span class="line">let [a, [b], d] = [1, [2, 3], 4];</span><br><span class="line">a // 1</span><br><span class="line">b // 2</span><br><span class="line">d // 4</span><br><span class="line">let [x, y, z] = new Set([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]);</span><br><span class="line">x // &quot;a&quot;</span><br><span class="line">// 报错</span><br><span class="line">let [foo] = 1;</span><br><span class="line">let [foo] = false;</span><br><span class="line">let [foo] = NaN;</span><br><span class="line">let [foo] = undefined;</span><br><span class="line">let [foo] = null;</span><br><span class="line">let [foo] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">let [x, y = &#x27;b&#x27;] = [&#x27;a&#x27;]; // x=&#x27;a&#x27;, y=&#x27;b&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>对象的解构赋值<br>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let &#123; bar, foo &#125; = &#123; foo: &#x27;aaa&#x27;, bar: &#x27;bbb&#x27; &#125;;</span><br><span class="line">foo // &quot;aaa&quot;</span><br><span class="line">bar // &quot;bbb&quot;</span><br><span class="line"></span><br><span class="line">let &#123; baz &#125; = &#123; foo: &#x27;aaa&#x27;, bar: &#x27;bbb&#x27; &#125;;</span><br><span class="line">baz // undefined</span><br><span class="line"></span><br><span class="line">const &#123; log &#125; = console;</span><br><span class="line">log(&#x27;hello&#x27;) // hello</span><br><span class="line"></span><br><span class="line">let &#123; foo: baz &#125; = &#123; foo: &#x27;aaa&#x27;, bar: &#x27;bbb&#x27; &#125;;</span><br><span class="line">baz // &quot;aaa&quot;</span><br><span class="line"></span><br><span class="line">let obj = &#123; first: &#x27;hello&#x27;, last: &#x27;world&#x27; &#125;;</span><br><span class="line">let &#123; first: f, last: l &#125; = obj;</span><br><span class="line">f // &#x27;hello&#x27;</span><br><span class="line">l // &#x27;world&#x27;</span><br><span class="line"></span><br><span class="line">var &#123; message: msg = &#x27;Something went wrong&#x27; &#125; = &#123;&#125;;</span><br><span class="line">msg // &quot;Something went wrong&quot;</span><br></pre></td></tr></table></figure></li><li>字符串的解构赋值<br>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const [a, b, c, d, e] = &#x27;hello&#x27;;</span><br><span class="line">a // &quot;h&quot;</span><br><span class="line">b // &quot;e&quot;</span><br><span class="line">c // &quot;l&quot;</span><br><span class="line">d // &quot;l&quot;</span><br><span class="line">e // &quot;o&quot;</span><br><span class="line"></span><br><span class="line">// 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。</span><br><span class="line">let &#123;length : len&#125; = &#x27;hello&#x27;;</span><br><span class="line">len // 5</span><br></pre></td></tr></table></figure></li><li>数值和布尔值的解构赋值<br>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let &#123;toString: s&#125; = 123;</span><br><span class="line">s === Number.prototype.toString // true</span><br><span class="line"></span><br><span class="line">let &#123;toString: s&#125; = true;</span><br><span class="line">s === Boolean.prototype.toString // true</span><br><span class="line">// 数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。</span><br></pre></td></tr></table></figure></li><li>函数参数的解构赋值<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function add([x, y])&#123;</span><br><span class="line">return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add([1, 2]); // 3</span><br></pre></td></tr></table></figure></li><li>注意点 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 错误的写法</span><br><span class="line">let x;</span><br><span class="line">&#123;x&#125; = &#123;x: 1&#125;;</span><br><span class="line">// SyntaxError: syntax error</span><br><span class="line"></span><br><span class="line">// 正确的写法</span><br><span class="line">let x;</span><br><span class="line">(&#123;x&#125; = &#123;x: 1&#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>延展操作符(Spread operator)<br>展开数组或者对象。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr1 = [0, 1, 2];</span><br><span class="line">var arr2 = [3, 4, 5];</span><br><span class="line">var arr3 = [...arr1, ...arr2];// 将 arr2 中所有元素附加到 arr1 后面并返回</span><br><span class="line">//等同于</span><br><span class="line">var arr4 = arr1.concat(arr2);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">var obj1 = &#123; foo: &#x27;bar&#x27;, x: 42 &#125;;</span><br><span class="line">var obj2 = &#123; foo: &#x27;baz&#x27;, y: 13 &#125;;</span><br><span class="line"> </span><br><span class="line">var clonedObj = &#123; ...obj1 &#125;;</span><br><span class="line">// 克隆后的对象: &#123; foo: &quot;bar&quot;, x: 42 &#125;</span><br><span class="line"> </span><br><span class="line">var mergedObj = &#123; ...obj1, ...obj2 &#125;;</span><br><span class="line">// 合并后的对象: &#123; foo: &quot;baz&quot;, x: 42, y: 13 &#125;</span><br></pre></td></tr></table></figure></li><li><p>对象属性简写<br><code>ES6</code>允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const foo = &#x27;bar&#x27;;</span><br><span class="line">const baz = &#123;foo&#125;;</span><br><span class="line">baz // &#123;foo: &quot;bar&quot;&#125;</span><br><span class="line">// 等同于</span><br><span class="line">const baz = &#123;foo: foo&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function f(x, y) &#123;</span><br><span class="line">  return &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">function f(x, y) &#123;</span><br><span class="line">  return &#123;x: x, y: y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(1, 2) // Object &#123;x: 1, y: 2&#125;</span><br></pre></td></tr></table></figure></li><li><p>promise<br>见<a href="https://www.jianshu.com/p/c8ebbc7d4c01">promise 简介</a></p></li><li><p>新增数组方法</p><ul><li>Array.from() ：方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arrayLike = &#123;</span><br><span class="line">    &#x27;0&#x27;: &#x27;a&#x27;,</span><br><span class="line">    &#x27;1&#x27;: &#x27;b&#x27;,</span><br><span class="line">    &#x27;2&#x27;: &#x27;c&#x27;,</span><br><span class="line">    length: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// ES5的写法</span><br><span class="line">var arr1 = [].slice.call(arrayLike); // [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br><span class="line"></span><br><span class="line">// ES6的写法</span><br><span class="line">let arr2 = Array.from(arrayLike); // [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br><span class="line"></span><br><span class="line">//如果参数是一个真正的数组，Array.from会返回一个一模一样的新数组。</span><br><span class="line">Array.from([1, 2, 3])</span><br><span class="line">// [1, 2, 3]</span><br></pre></td></tr></table></figure></li><li>Array.of():用于将一组值，转换为数组。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Array.of(3, 11, 8) // [3,11,8]</span><br><span class="line">Array.of(3) // [3]</span><br><span class="line">Array.of(3).length // 1</span><br><span class="line">Array.of(undefined) // [undefined]</span><br></pre></td></tr></table></figure></li><li>copyWithin():在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2。</span><br><span class="line">[1, 2, 3, 4, 5].copyWithin(0, 3)</span><br><span class="line">// [4, 5, 3, 4, 5]</span><br></pre></td></tr></table></figure></li><li>find() 和 findIndex():用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。findIndex返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1, 4, -5, 10].find((n) =&gt; n &lt; 0)</span><br><span class="line">// -5</span><br><span class="line">[1, 5, 10, 15].findIndex(function(value, index, arr) &#123;</span><br><span class="line">return value &gt; 9;</span><br><span class="line">&#125;) // 2</span><br></pre></td></tr></table></figure></li><li>fill():使用给定值，填充一个数组。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;].fill(7)</span><br><span class="line">// [7, 7, 7]</span><br><span class="line"></span><br><span class="line">new Array(3).fill(7)</span><br><span class="line">// [7, 7, 7]</span><br></pre></td></tr></table></figure></li><li>entries()，keys() 和 values()<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (let index of [&#x27;a&#x27;, &#x27;b&#x27;].keys()) &#123;</span><br><span class="line">console.log(index);</span><br><span class="line">&#125;</span><br><span class="line">// 0</span><br><span class="line">// 1</span><br><span class="line"></span><br><span class="line">for (let elem of [&#x27;a&#x27;, &#x27;b&#x27;].values()) &#123;</span><br><span class="line">console.log(elem);</span><br><span class="line">&#125;</span><br><span class="line">// &#x27;a&#x27;</span><br><span class="line">// &#x27;b&#x27;</span><br><span class="line"></span><br><span class="line">for (let [index, elem] of [&#x27;a&#x27;, &#x27;b&#x27;].entries()) &#123;</span><br><span class="line">console.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line">// 0 &quot;a&quot;</span><br><span class="line">// 1 &quot;b&quot;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>数值的扩展方法</p><ul><li>Number.isFinite(), Number.isNaN()<br>它们与传统的全局方法<code>isFinite()</code>和<code>isNaN()</code>的区别在于，传统方法先调用<code>Number()</code>将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，<code>Number.isFinite()</code>对于非数值一律返回<code>false</code>, <code>Number.isNaN()</code>只有对于NaN才返回<code>true</code>，非NaN一律返回<code>false</code>。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Number.isFinite(15); // true</span><br><span class="line">Number.isFinite(0.8); // true</span><br><span class="line">Number.isFinite(NaN); // false</span><br><span class="line">Number.isFinite(Infinity); // false</span><br><span class="line">Number.isFinite(-Infinity); // false</span><br><span class="line">Number.isFinite(&#x27;foo&#x27;); // false</span><br><span class="line">Number.isFinite(&#x27;15&#x27;); // false</span><br><span class="line">Number.isFinite(true); // false</span><br><span class="line"></span><br><span class="line">Number.isNaN(NaN) // true</span><br><span class="line">Number.isNaN(15) // false</span><br><span class="line">Number.isNaN(&#x27;15&#x27;) // false</span><br><span class="line">Number.isNaN(true) // false</span><br><span class="line">Number.isNaN(9/NaN) // true</span><br><span class="line">Number.isNaN(&#x27;true&#x27; / 0) // true</span><br><span class="line">Number.isNaN(&#x27;true&#x27; / &#x27;true&#x27;) // true</span><br></pre></td></tr></table></figure></li><li>Number.parseInt(), Number.parseFloat()<br><code>ES6</code>将全局方法<code>parseInt()</code>和<code>parseFloat()</code>，移植到<code>Number</code>对象上面，行为完全保持不变。这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ES5的写法</span><br><span class="line">parseInt(&#x27;12.34&#x27;) // 12</span><br><span class="line">parseFloat(&#x27;123.45#&#x27;) // 123.45</span><br><span class="line"></span><br><span class="line">// ES6的写法</span><br><span class="line">Number.parseInt(&#x27;12.34&#x27;) // 12</span><br><span class="line">Number.parseFloat(&#x27;123.45#&#x27;) // 123.45</span><br></pre></td></tr></table></figure></li><li>Number.isInteger()<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Number.isInteger(25) // true</span><br><span class="line">Number.isInteger(25.1) // false</span><br><span class="line">// JavaScript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值。</span><br><span class="line">Number.isInteger(25.0) // true</span><br></pre></td></tr></table></figure></li><li>Number.EPSILON:<code>ES6</code>在<code>Number</code>对象上面，新增一个极小的常量<code>Number.EPSILON</code>。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Number.EPSILON === Math.pow(2, -52)</span><br><span class="line">// true</span><br><span class="line">Number.EPSILON</span><br><span class="line">// 2.220446049250313e-16</span><br><span class="line">Number.EPSILON.toFixed(20)</span><br><span class="line">// &quot;0.00000000000000022204&quot;</span><br></pre></td></tr></table></figure></li><li>MIN_SAFE_INTEGER和MAX_SAFE_INTEGER：<code>JavaScript</code>能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。<code>ES6</code>引入了<code>Number.MAX_SAFE_INTEGER</code>和<code>Number.MIN_SAFE_INTEGER</code>这两个常量，用来表示这个范围的上下限。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1</span><br><span class="line">// true</span><br><span class="line">Number.MAX_SAFE_INTEGER === 9007199254740991</span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">Number.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER</span><br><span class="line">// true</span><br><span class="line">Number.MIN_SAFE_INTEGER === -9007199254740991</span><br><span class="line">// true</span><br></pre></td></tr></table></figure></li><li>Number.isSafeInteger()<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Number.isSafeInteger(10);    // true</span><br><span class="line">Number.isSafeInteger(12345678901234567890);  // false</span><br></pre></td></tr></table></figure></li><li>Math.trunc(): 用于去除一个数的小数部分，返回整数部分。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Math.trunc(4.1) // 4</span><br><span class="line">Math.trunc(4.9) // 4</span><br><span class="line">Math.trunc(-4.1) // -4</span><br><span class="line">// 对于空值和无法截取整数的值，返回NaN</span><br><span class="line">Math.trunc(NaN);      // NaN</span><br><span class="line">Math.trunc(&#x27;foo&#x27;);    // NaN</span><br><span class="line">Math.trunc();         // NaN</span><br><span class="line">Math.trunc(undefined) // NaN</span><br></pre></td></tr></table></figure></li></ul></li></ol><H3> ES7(ES2016)新特性 </H3><ol><li>includes()<br>该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它的绝对值大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1, 2, 3].includes(2)     // true</span><br><span class="line">[1, 2, 3].includes(4)     // false</span><br><span class="line">[1, 2, NaN].includes(NaN) // true</span><br><span class="line">[1, 2, 3].includes(3, 3);  // false</span><br><span class="line">[1, 2, 3].includes(3, -1); // true</span><br></pre></td></tr></table></figure></li><li>指数运算符<br>它与 <code>Math.pow(a, b)</code>相同。这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 相当于 2 ** (3 ** 2)</span><br><span class="line">2 ** 3 ** 2</span><br><span class="line">// 512</span><br><span class="line"></span><br><span class="line">let a = 1.5;</span><br><span class="line">a **= 2;</span><br><span class="line">// 等同于 a = a * a;</span><br><span class="line">let b = 4;</span><br><span class="line">b **= 3;</span><br><span class="line">// 等同于 b = b * b * b;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端基础知识 </category>
          
          <category> Js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> ES6 </tag>
            
            <tag> ES2015 </tag>
            
            <tag> ES7 </tag>
            
            <tag> ES2016 </tag>
            
            <tag> 前端基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>介绍模块化发展历程</title>
      <link href="/2021/07/30/%E4%BB%8B%E7%BB%8D%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/"/>
      <url>/2021/07/30/%E4%BB%8B%E7%BB%8D%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<H3> 第一阶段——无模块化 </H3><ol><li>将所有<code>JS</code>文件都放在一块，代码执行顺序就按照文件的顺序执行。</li><li>缺点是污染全局作用域。每一个模块都是暴露在全局中的，容易产生命名冲突。还有要手动处理各代码的依赖关系。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;jquery.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;jquery_scroller.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;other.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><H3> 第二阶段——commonJS规范 </H3><p>是一个<code>JavaScript</code>模块化的规范，一个文件就是一个模块，内部定义的变量就属于这个模块里的，不会对外暴露，所以不会污染全局变量。</p><ol><li>通过require引入模块</li><li>通过module.exports导出模块<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//a.js</span><br><span class="line">var num = 100;</span><br><span class="line">var add = function(val)&#123;</span><br><span class="line">   return val + num</span><br><span class="line">&#125;</span><br><span class="line">module.exports.num = num;</span><br><span class="line">module.exports.add = add ;</span><br><span class="line">//b.js</span><br><span class="line">var moduleA = require(&#x27;./a.js&#x27;)</span><br><span class="line">var fn = moduleA.add;</span><br></pre></td></tr></table></figure></li><li>同步加载模块，等当前模块加载完成了才进行下一步，服务器端文件都是保存在硬盘上，所以同步加载没问题。但是浏览器上，需要把文件从服务器端请求过来，比较慢，所以同步加载不适合用在浏览器上</li></ol><H3> 第三阶段——AMD规范 </H3><p>因为<code>commonJS</code>规范不适用于浏览器，因为要从服务器加载文件，不能用同步模式，所以有了<code>AMD</code>规范，该规范的实现，就是<code>requireJs</code>了。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">define(function () &#123;</span><br><span class="line">    var alertName = function (str) &#123;</span><br><span class="line">      alert(&quot;I am &quot; + str);</span><br><span class="line">    &#125;</span><br><span class="line">    var alertAge = function (num) &#123;</span><br><span class="line">      alert(&quot;I am &quot; + num + &quot; years old&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">      alertName: alertName,</span><br><span class="line">      alertAge: alertAge</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">//引入模块：</span><br><span class="line">require([&#x27;alert&#x27;], function (alert) &#123;</span><br><span class="line">  alert.alertName(&#x27;JohnZhu&#x27;);</span><br><span class="line">  alert.alertAge(21);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol><li>依赖前置，require([dep1, dep2],callback)，先加载依赖再执行回调函数</li><li>优点是可以在浏览器环境中异步加载模块，而且可以并行加载多个模块</li></ol><H3> 第四阶段——CMD规范 </H3><p>和<code>requirejs</code>非常类似，即一个<code>js文</code>件就是一个模块，但是可以通过按需加载的方式，而不是必须在模块开始就加载所有的依赖。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line">  var $ = require(&#x27;jquery&#x27;);</span><br><span class="line">  var Spinning = require(&#x27;./spinning&#x27;);</span><br><span class="line">  exports.doSomething = ...</span><br><span class="line">  module.exports = ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><H3> 特殊规范——UMD </H3><p><code>CommonJS、AMD、CMD</code>并行的状态下，就需要一种方案能够兼容他们，这样我们在开发时，就不需要再去考虑依赖模块所遵循的规范了，而<code>UMD</code>的出现就是为了解决这个问题。</p><H3> 第五阶段——ES6的模块化 </H3><ol><li>定义：通过<code>import</code>引入依赖，通过<code>export</code>导出依赖</li><li>机制：<code>ES6</code>的模块机制在依赖模块时并不会先去预加载整个脚本，而是生成一个只读引用，并且静态解析依赖，等到执行代码时，再去依赖里取出实际需要的模块</li><li>特点：编译时加载，不允许在里边引用变量，必须为真实的文件路径。可以通过调用<code>import()</code>语句，会生成一个<code>promise</code>去加载对应的文件，这样子就是运行时加载，可以在路径里边编写变量</li><li>缺点：浏览器暂不支持，需要<code>babel</code>编译过</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端基础知识 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 模块化 </tag>
            
            <tag> 工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试题-网络篇</title>
      <link href="/2021/07/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%BD%91%E7%BB%9C%E7%AF%87/"/>
      <url>/2021/07/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%BD%91%E7%BB%9C%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<H3> cookie的属性和作用 </H3><p>cookie如图：<br><img src="https://upload-images.jianshu.io/upload_images/17463653-6cfbae8bc2a6ba09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>一个域名下面可能存在着很多个cookie对象。</p><ol><li>Name：一个cookie的名称</li><li>Value：一个cookie的值</li><li>Domain：<code>cookie</code>的域。如果设成<code>.test.com</code>，那么子域名<code>a.test.com和b.test.com</code>，都可以使用<code>.test.com</code>的<code>cookie</code></li><li>Path：可以访问此<code>cookie</code>的页面路径，一般设置成/即可</li><li><code>Expires/Max-Age</code>：<code>cookie</code>过期时间。不设置，则为<code>Session</code>会话期，关闭页面，<code>cookie</code>失效。若设置其值为一个时间，那么当到达此时间后，此<code>cookie</code>失效</li><li>Size：此<code>cookie</code>大小。</li><li>HttpOnly：若此属性为<code>true</code>，则只有在<code>http</code>请求头中会带有此<code>cookie</code>的信息，而不能通过<code>document.cookie</code>来访问此<code>cookie</code>。</li><li>Secure：标记为<code>Secure</code>的<code>cookie</code>，只能通过<code>https</code>请求发送</li><li>SameSite：用来防止<code>CSRF</code>攻击和用户追踪。有3个值：<code>Strict/Lax/None</code>。<ul><li>Strict: 最为严格，完全禁止第三方 <code>Cookie</code>，跨站点时，任何情况下都不会发送<code>Cookie</code>,仅允许发送同站点请求的的<code>cookie</code></li><li>Lax: 允许部分第三方请求携带<code>cookie</code>，即导航到目标网址的<code>get</code>请求。包括超链接<code>&lt;a href=&#39;...&#39; /&gt;</code>，预加载<code>&lt;link rel=&quot;prerender&quot; /&gt;</code>和<code>get</code>表单<code>&lt;form method=&quot;GET&quot; /&gt;</code>三种形式发送<code>cookie</code></li><li>None: 设置为<code>None</code>，任意发送<code>cookie</code>，需要同时设置<code>Secure</code>，意味着网站必须采用<code>https</code>，若同时支持<code>http</code>和<code>https</code>，可以将<code>http</code>用<code>307</code>跳转到<code>https</code></li></ul></li><li>Priority：优先级，<code>chrome</code>的提案，定义了三种优先级，<code>Low/Medium/High</code>，当<code>cookie</code>数量超出时，低优先级的<code>cookie</code>会被优先清除</li></ol><H3> 说一下浏览器缓存 </H3><p>浏览器缓存分为强缓存和协商缓存，强缓存会直接从浏览器里面拿数据，协商缓存会先访问服务器看缓存是否过期，再决定是否从浏览器里面拿数据。</p><ol><li>控制强缓存的字段有：<code>Expires</code>和<code>Cache-Control</code><br>，若同时设置了<code>Cache-Control和Expires</code>，<code>Cache-Control</code>的优先级高于<code>Expires</code>。</li><li>控制协商缓存的字段有：<code>Last-Modified / If-Modified-Since </code>和 <code>Etag / If-None-Match</code>，其中 <code>Etag / If-None-Match</code>的优先级比<code>Last-Modified / If-Modified-Since</code>高，因为它被认为更准确。</li></ol><H3> 说一下url输入到页面呈现的过程 </H3><p>这个过程还是很复杂的，大致的步骤如下：</p><ol><li>根据输入的网址向<code>DNS（Domain Name Systerm）</code>查询<code>IP</code></li><li>通过<code>IP</code>向服务器发起<code>tcp</code>连接</li><li>向服务器发起请求</li><li>服务器返回请求内容</li><li>浏览器开始解析渲染页面并显示</li><li>关闭连接</li></ol><p>详细内容可以查看这篇文章<br><a href="https://segmentfault.com/a/1190000013522717">https://segmentfault.com/a/1190000013522717</a></p><H3> 介绍一下http2 </H3><ol><li>HTTP发展史<ul><li>HTTP/0.9 - 单行协议：<code>HTTP</code>于1990年问世，那时候<code>HTTP</code>非常简单：只支持<code>GET</code>方法；没有首部；只能获取纯文本。</li><li>HTTP/1.0 - 搭建协议的框架：1996年，<code>HTTP</code>正式被作为标准公布，版本为<code>HTTP/1.0</code>。1.0版本增加了首部、状态码、权限、缓存、长连接（默认短连接）等规范，可以说搭建了协议的基本框架。</li><li>HTTP/1.1 - 进一步完善：1997年，1.1版本接踵而至。1.1版本的重大改进在于默认长连接；强制客户端提供<code>Host</code>首部；管线化；<code>Cache-Control</code>、<code>ETag</code>等缓存的相关扩展。</li></ul></li><li>HTTP1.1目前存在的问题<ul><li>线头阻塞：<code>TCP</code>连接上只能发送一个请求，前面的请求未完成前，后续的请求都在排队等待。</li><li>多个TCP连接：虽然HTTP/1.1管线化可以支持请求并发，但是浏览器很难实现，<code>chrome、firefox</code>等都禁用了管线化。所以1.1版本请求并发依赖于多个<code>TCP</code>连接，建立<code>TCP</code>连接成本很高，还会存在慢启动的问题。</li><li>头部冗余，采用文本格式：<code>HTTP/1.X</code>版本是采用文本格式，首部未压缩，而且每一个请求都会带上<code>cookie、user-agent</code>等完全相同的首部。</li><li>客户端需要主动请求</li></ul></li><li>HTTP2.0改进<ul><li>二进制分帧层：<code>HTTP2</code>性能提升的核心就在于二进制分帧层。<code>HTTP2</code>是二进制协议，他采用二进制格式传输数据而不是1.x的文本格式。</li><li>多路复用：<code>HTTP2</code>的多路复用完美解决了<code>HTTP/1.1</code>的线头阻塞和多个<code>TCP</code>连接的问题。<code>HTTP2</code>让所有的通信都在一个<code>TCP</code>连接上完成，真正实现了请求的并发。</li><li>头部压缩：头部压缩也是<code>HTTP2</code>的一大亮点。在1.X版本中，首部用文本格式传输，通常会给每个传输增加500-800字节的开销。现在打开一个网页上百个请求已是常态，而每个请求带的一些首部字段都是相同的，例如<code>cookie、user-agent</code>等。<code>HTTP2</code>为此采用<code>HPACK</code>压缩格式来压缩首部。头部压缩需要在浏览器和服务器端之间：维护一份相同的静态字典，包含常见的头部名称，以及常见的头部名称和值的组合；维护一份相同的动态字典，可以动态的添加内容；通过静态<code>Huffman</code>编码对传输的首部字段进行编码。</li><li>服务器端推送：服务器端推送使得服务器可以预测客户端需要的资源，主动推送到客户端。<br>例如：客户端请求<code>index.html</code>，服务器端能够额外推送<code>script.js和style.css</code>。<br>实现原理就是客户端发出页面请求时，服务器端能够分析这个页面所依赖的其他资源，主动推送到客户端的缓存，当客户端收到原始网页的请求时，它需要的资源已经位于缓存。针对每一个希望发送的资源，服务器会发送一个<code>PUSH_PROMISE</code>帧，客户端可以通过发送<code>RST_STREAM</code>帧来拒绝推送（当资源已经位于缓存）。这一步的操作先于父响应（index.html），客户端了解到服务器端打算推送哪些资源，就不会再为这些资源创建重复请求。当客户端收到<code>index.html</code>的响应时，<code>script.js</code>和<code>style.css</code>已经位于缓存。</li></ul></li></ol><H3> 介绍下重绘和回流（Repaint & Reflow），以及如何进行优化 </H3><ol><li><p>浏览器渲染机制</p><ul><li>浏览器采用流式布局模型<code>（Flow Based Layout）</code></li><li>浏览器会把<code>HTML</code>解析成<code>DOM</code>，把<code>CSS</code>解析成<code>CSSOM</code>，<code>DOM</code>和<code>CSSOM</code>合并就产生了渲染树<code>（Render Tree）</code>。</li><li>有了<code>RenderTree</code>，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。</li><li>由于浏览器使用流式布局，对<code>Render Tree</code>的计算通常只需要遍历一次就可以完成，但<code>table</code>及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用<code>table</code>布局的原因之一。</li></ul></li><li><p>重绘<br>由于节点的几何属性发生改变或者由于样式发生改变而不会影响布局的，称为重绘，例如<code>outline</code>, <code>visibility, color、background-color</code>等，重绘的代价是高昂的，因为浏览器必须验证<code>DOM</code>树上其他节点元素的可见性。</p></li><li><p>回流</p><ul><li>回流是布局或者几何属性需要改变就称为回流。回流是影响浏览器性能的关键因素，因为其变化涉及到部分页面（或是整个页面）的布局更新。一个元素的回流可能会导致了其所有子元素以及<code>DOM</code>中紧随其后的节点、祖先节点元素的随后的回流。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;error&quot;&gt;</span><br><span class="line">    &lt;h4&gt;我的组件&lt;/h4&gt;</span><br><span class="line">    &lt;p&gt;&lt;strong&gt;错误：&lt;/strong&gt;错误的描述…&lt;/p&gt;</span><br><span class="line">    &lt;h5&gt;错误纠正&lt;/h5&gt;</span><br><span class="line">    &lt;ol&gt;</span><br><span class="line">        &lt;li&gt;第一步&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;第二步&lt;/li&gt;</span><br><span class="line">    &lt;/ol&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li><li>在上面的<code>HTML</code>片段中，对该段落(<code>&lt;p&gt;</code>标签)回流将会引发强烈的回流，因为它是一个子节点。这也导致了祖先的回流（<code>div.error</code>和<code>body</code> – 视浏览器而定）。此外，<code>&lt;h5&gt;</code>和<code>&lt;ol&gt;</code>也会有简单的回流，因为其在<code>DOM</code>中在回流元素之后。大部分的回流将导致页面的重新渲染。</li><li>回流必定会发生重绘，重绘不一定会引发回流。</li></ul></li><li><p>浏览器优化<br>现代浏览器大多都是通过队列机制来批量更新布局，浏览器会把修改操作放在队列中，至少一个浏览器刷新（即16.6ms）才会清空队列，但当你获取布局信息的时候，队列中可能有会影响这些属性或方法返回值的操作，即使没有，浏览器也会强制清空队列，触发回流与重绘来确保返回正确的值。<br>所以，我们应该避免频繁的使用下述的属性或方法，他们都会强制渲染刷新队列。</p><ul><li><code>offsetTop 、offsetLeft、 offsetWidth、offsetHeight</code></li><li><code>scrollTop、scrollLeft、scrollWidth、scrollHeight</code></li><li><code>clientTop、clientLeft、clientWidth、clientHeight</code></li><li><code>width、height</code></li><li><code>getComputedStyle()、getBoundingClientRect()</code></li></ul></li><li><p>减少重绘与回流</p></li></ol><ul><li><p>css方面</p><ul><li>使用 <code>transform</code> 替代 <code>top</code></li><li>使用 <code>visibility</code> 替换 <code>display: none</code> ，因为前者只会引起重绘，后者会引发回流（改变了布局</li><li>避免使用<code>table</code>布局，可能很小的一个小改动会造成整个 <code>table</code> 的重新布局。</li><li>尽可能在<code>DOM</code>树的最末端改变<code>class</code>，回流是不可避免的，但可以减少其影响。尽可能在<code>DOM</code>树的最末端改变<code>class</code>，可以限制了回流的范围，使其影响尽可能少的节点。</li><li>避免设置多层内联样式，<code>CSS</code> 选择符从右往左匹配查找，避免节点层级过多。</li></ul>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;a&gt; &lt;span&gt;&lt;/span&gt; &lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">span &#123;</span><br><span class="line">    color: red;</span><br><span class="line">    &#125;</span><br><span class="line">div &gt; a &gt; span &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">// 对于第一种设置样式的方式来说，浏览器只需要找到页面中所有的span标签然后设置颜色</span><br><span class="line">// 但是对于第二种设置样式的方式来说，浏览器首先需要找到所有的span标签，然后找到span标签上的a标签，最后再去找到div标签，然后给符合这种条件的span标签设置颜色，这样的递归过程就很复杂</span><br><span class="line">// 所以我们应该尽可能的避免写过于具体的CSS选择器，然后对于 HTML 来说也尽量少的添加无意义标签，保证层级扁平</span><br></pre></td></tr></table></figure><ul><li>将动画效果应用到<code>position</code>属性为<code>absolute</code>或<code>fixed</code>的元素上，避免影响其他元素的布局，这样只是一个重绘，而不是回流，同时，控制动画速度可以选择 <code>requestAnimationFrame</code></li><li>避免使用<code>CSS</code>表达式，可能会引发回流。</li><li>将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点，例如<code>will-change</code>、<code>video</code>、<code>iframe</code>等标签，浏览器会自动将该节点变为图层。</li><li>CSS3 硬件加速（GPU加速），使用css3硬件加速，可以让<code>transform</code>、<code>opacity</code>、<code>filters</code>这些动画不会引起回流重绘 。但是对于动画的其它属性，比如<code>background-color</code>这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。</li></ul></li><li><p>JavaScript方面</p><ul><li>避免频繁操作样式，最好一次性重写<code>style</code>属性，或者将样式列表定义为<code>class</code>并一次性更改<code>class</code>属性。</li><li>避免频繁操作<code>DOM</code>，创建一个<code>documentFragment</code>，在它上面应用所有<code>DOM</code>操作，最后再把它添加到文档中。</li><li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li><li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li></ul></li></ul><H3> 状态码及含义 </H3><ol><li>1**：信息状态码，<code>100 continue</code>继续</li><li>2**：成功状态码， <code>200</code> 成功， <code>201—created</code> 创建新资源，<code>202—accep</code>t 服务器已接收，尚未处理</li><li>3**：重定向，<code>301—永久重定向</code>， <code>302—临时性重定向</code>，<code>303—临时性重定</code>，<code>304—not modified</code> 上次访问之后没有进行修改</li><li>4**：客户端错误 <code>400—bad request </code>，<code>401-未授权</code> ，<code>403-forbidden</code>禁止访问，<code>404-not found</code></li><li>5**：服务端错误 <code>500 503</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端面试题 </category>
          
          <category> 网络篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端面试题 </tag>
            
            <tag> 前端 </tag>
            
            <tag> 前端基础知识 </tag>
            
            <tag> 网络 </tag>
            
            <tag> HTTP </tag>
            
            <tag> HTTP2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React、React-Redux、Redux-saga用法总结</title>
      <link href="/2021/07/30/React%E3%80%81React-Redux%E3%80%81Redux-saga%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2021/07/30/React%E3%80%81React-Redux%E3%80%81Redux-saga%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<H3> React有props和state </H3><ol><li><code>props</code>意味着父级分发下来的属性</li><li><code>state</code>意味着组件内部可以自行管理的状态，并且整个<code>react</code>没有数据向上回溯的能力，这就是<code>react</code>的单向数据流。这就意味着如果是一个数据状态非常复杂的应用，更多的时候发现<code>react</code>根本无法让两个组件互相交流，使用对方的数据，<code>react</code>的通过层级传递数据的这种方法是非常难受的，这个时候，迫切需要一个机制，把所有的<code>state</code>集中到组件顶部，能够灵活的将所有<code>state</code>各取所需的分发给所有的组件，这就是<code>redux</code></li></ol><H3> Redux的诞生是为了给 React 应用提供「可预测化的状态管理」机制 </H3><ol><li><code>Redux</code>会将整个应用状态(其实也就是数据)存储到到一个地方，称为<code>store</code>（就是一个数据池，一个应用只有一个），这个<code>store</code>里面保存一棵状态树<code>(state tree)</code>，组件改变<code>state</code>的唯一方法是通过调用<code>store</code>的<code>dispatch</code>方法，触发一个<code>action</code>，这个<code>action</code>被对应的<code>reducer</code>（reducer就是改变state的处理层，它接收action和state，通过处理action来返回新的state）处理，于是<code>state</code>完成更新<br>组件可以派发(dispatch)行为(action)给<code>store</code>,而不是直接通知其它组件，其它组件可以通过订阅<code>store</code>中的状态(state)来刷新自己的视图</li><li>使用步骤<ul><li>创建reducer<br>可以使用单独的一个<code>reducer</code>,也可以将多个<code>reducer</code>合并为一个<code>reducer</code>，即：combineReducers();<br><code>action</code>发出命令后将<code>state</code>放入<code>reducer</code>加工函数中，返回新的<code>state</code>,对<code>state</code>进行加工处理</li><li>创建action<br>用户是接触不到<code>state</code>的，只能由<code>view</code>触发，<code>action</code>可以理解为指令，需要发出多少动作就有多少指令，<code>action</code>是一个对象，其中的<code>type</code>属性是必须的，定义<code>action</code>类型，其他属性可以自由设置</li><li>创建<code>store</code>，使用<code>createStore</code>方法。<code>store</code>可以理解为有多个加工机器的总工厂，提供<code>subscribe</code>，<code>dispatch</code>，<code>getState</code>这些方法。<br><img src="https://upload-images.jianshu.io/upload_images/17463653-137b89378cc7ab45.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></li></ul></li></ol><H3> 把store直接集成到React应用的顶层props里 </H3><p>如果把<code>store</code>直接集成到<code>React</code>应用的顶层<code>props</code>里面，只要各个子组件能访问到顶层<code>props</code>就可以了,比如这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;顶层组件 store=&#123;store&#125;&gt;</span><br><span class="line"> &lt;App /&gt;</span><br><span class="line">&lt;/顶层组件&gt;</span><br></pre></td></tr></table></figure><p>这就是<code>react-redux</code>,是为了让<code>redux</code>更好的适用于<code>react</code>而生的一个库。<code>react-redux</code>将组件区分为容器组件和<code>UI</code>组件，前者会处理逻辑，后者只负责显示和交互，内部不处理逻辑，状态完全由外部掌控。</p><ol><li><p>两个核心</p><ul><li>Provider<br>一般我们都将顶层组件包裹在Provider组件之中，这样，所有组件就都可以在react-redux的控制之下了，但是store必须作为参数放到Provider组件中。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Provider store = &#123;store&#125;&gt;</span><br><span class="line">&lt;App /&gt;</span><br><span class="line">&lt;Provider&gt;</span><br><span class="line">// 这样，所有组件都能够访问到Redux中的数据</span><br></pre></td></tr></table></figure></li><li>connect<br>这个方法可以从UI组件生成容器组件，但容器组件的定位是处理数据、响应行为，因此，需要对UI组件添加额外的东西，即mapStateToProps和mapDispatchToProps，也就是在组件外加了一层state，用法如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">connect(mapStateToProps, mapDispatchToProps)(MyComponent)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>mapStateToProps<br>把Redux中的数据映射到React中的props中去，举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const mapStateToProps = (state) =&gt; &#123;</span><br><span class="line">   return &#123;</span><br><span class="line">     foo: state.bar</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后渲染的时候就可以使用<code>this.props.foo</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Foo extends Component &#123;</span><br><span class="line"> constructor(props)&#123;</span><br><span class="line">  super(props);</span><br><span class="line"> &#125;</span><br><span class="line"> render()&#123;</span><br><span class="line">  return(</span><br><span class="line">   &lt;div&gt;this.props.foo&lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">Foo = connect()(Foo);</span><br><span class="line">export default Foo;</span><br></pre></td></tr></table></figure><p>然后这样就可以完成渲染了</p></li><li><p>mapDispatchToProps<br>把各种<code>dispatch</code>也变成了可以直接使用的<code>props</code>，举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const mapDispatchToProps = (dispatch) =&gt; &#123; </span><br><span class="line"> return &#123;</span><br><span class="line">   onClick: () =&gt; &#123;</span><br><span class="line">    dispatch(&#123;type: &#x27;increatment&#x27;&#125;);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Foo extends Component &#123;</span><br><span class="line"> constructor(props)&#123;</span><br><span class="line">  super(props);</span><br><span class="line"> &#125;</span><br><span class="line"> render()&#123;</span><br><span class="line">  return(</span><br><span class="line">    &lt;button onClick = &#123;this.props.onClick&#125;&gt;click increase&lt;/button&gt;</span><br><span class="line">  )</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">Foo = connect()(Foo);</span><br><span class="line">export default Foo;</span><br></pre></td></tr></table></figure><p>组件可以直接通过<code>this.props.onClick</code>来调用<code>dispatch</code>,就不需要在代码中来进行<code>store.dispatch</code>了</p></li></ol><H3> 中间件 </H3><p>如果按照原始的<code>redux</code>工作流程，当组件中产生一个<code>action</code>后会直接触发<code>reducer</code>修改<code>state</code>，<code>reducer</code>又是一个纯函数，也就是不能在<code>reducer</code>中进行异步操作；而往往实际中，组件中发生的<code>action</code>在进入<code>reducer</code>之前需要完成一个异步任务（比如发送ajax请求），拿到数据后再进入<code>reducer</code>，这个时候就需要一个中间件来处理这种业务场景，目前最优雅的处理方式是<code>redux-saga</code>中间件，它通过<code>Generator</code>函数来创建，可以用同步的方式写异步的代码，目的是更好、更易地解决异步操作（把所有异步请求集中处理）。<br><code>redux-saga</code>提供了一些辅助函数，用来在一些特定的<code>action</code>被发起到<code>Store</code>时派生任务，我们先来看两个辅助函数：<code>takeEvery</code>和<code>takeLatest</code></p><ol><li><p>takeEvery<br><code>takeEvery</code>，同一个<code>action</code>多次触发，每个都会执行。<br>例如：每次点击按钮去<code>Fetch</code>数据时，我们发起一个<code>FETCH_REQUESTED</code>的<code>action</code>，想通过启动一个任务从服务器获取一些数据，来处理这个<code>action</code><br>首先创建一个将执行异步<code>action</code>的任务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// put：你就认为put就等于 dispatch就可以了</span><br><span class="line">// call：可以理解为实行一个异步函数,是阻塞型的，只有运行完后面的函数，才会继续往下</span><br><span class="line">import &#123; call, put &#125; from &#x27;redux-saga/effects&#x27;</span><br><span class="line">export function* fetchData(action) &#123;</span><br><span class="line"> try &#123;</span><br><span class="line">  const apiAjax = (params) =&gt; fetch(url, params);</span><br><span class="line">  const data = yield call(apiAjax);</span><br><span class="line">  yield put(&#123;type: &quot;FETCH_SUCCEEDED&quot;, data&#125;);</span><br><span class="line"> &#125; catch (error) &#123;</span><br><span class="line">  yield put(&#123;type: &quot;FETCH_FAILED&quot;, error&#125;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在每次<code>FETCH_REQUESTED action </code>被发起时启动上面的任务,也就相当于每次触发一个名字为 <code>FETCH_REQUESTED</code>的<code>action</code>就会执行上边的任务,代码如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; takeEvery &#125; from &#x27;redux-saga&#x27;</span><br><span class="line">function* watchFetchData() &#123;</span><br><span class="line"> yield* takeEvery(&quot;FETCH_REQUESTED&quot;, fetchData)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>takeLatest<br>在上面的例子中，<code>takeEvery</code>允许多个<code>fetchData</code>实例同时启动，在某个特定时刻，我们可以启动一个新的 <code>fetchData </code>任务， 尽管之前还有一个或多个 <code>fetchData </code>尚未结束，如果我们只想得到最新那个请求的响应（例如，始终显示最新版本的数据），我们可以使用 <code>takeLatest </code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; takeLatest &#125; from &#x27;redux-saga&#x27;</span><br><span class="line">function* watchFetchData() &#123;</span><br><span class="line"> yield* takeLatest(&#x27;FETCH_REQUESTED&#x27;, fetchData)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和<code>takeEvery</code>不同，在任何时刻<code>takeLatest</code>只允许执行一个<code>fetchData</code>任务，并且这个任务是最后被启动的那个，如果之前已经有一个任务在执行，那之前的这个任务会自动被取消</p></li><li><p>Effect Creators<br><code>redux-saga</code>框架提供了很多创建<code>effect</code>的函数，下面我们就来简单的介绍下开发中最常用的几种</p><ul><li>take(pattern)<br><code>take</code>函数可以理解为监听未来的<code>action</code>，它创建了一个命令对象，告诉<code>middleware</code>等待一个特定的<code>action</code>，<code>Generator</code>会暂停，直到一个与<code>pattern</code>匹配的<code>action</code>被发起，才会继续执行下面的语句，也就是说，<code>take</code>是一个阻塞的 <code>effect</code>，用法：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function* watchFetchData() &#123;</span><br><span class="line">while(true) &#123;</span><br><span class="line">// 监听一个type为 &#x27;FETCH_REQUESTED&#x27; 的action的执行，直到等到这个Action被触发，才会接着执行下面的 yield fork(fetchData) 语句</span><br><span class="line">yield take(&#x27;FETCH_REQUESTED&#x27;);</span><br><span class="line">yield fork(fetchData);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>put(action)<br><code>put</code>函数是用来发送<code>action</code>的<code>effect</code>，你可以简单的把它理解成为<code>redux</code>框架中的<code>dispatch</code>函数，当<code>put</code>一个<code>action</code>后，<code>reducer</code>中就会计算新的<code>state</code>并返回，<code>put</code> 也是阻塞 <code>effect</code>，用法：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export function* toggleItemFlow() &#123;</span><br><span class="line">let list = []</span><br><span class="line">// 发送一个type为 &#x27;UPDATE_DATA&#x27; 的Action，用来更新数据，参数为 `data：list`</span><br><span class="line">yield put(&#123;</span><br><span class="line">type: actionTypes.UPDATE_DATA,</span><br><span class="line">data: list</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>call(fn, …args)<br><code>call</code>函数简单的理解为可以调用其他函数的函数，它命令<code>middleware</code>来调用<code>fn</code>函数，<code>args</code>为函数的参数，注意：<code>fn</code>函数可以是一个<code>Generator</code>函数，也可以是一个返回<code>Promise</code>的普通函数，<code>call</code>函数也是阻塞<code>effect</code>，用法：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export const delay = ms =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms))</span><br><span class="line">export function* removeItem() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">// 这里call 函数就调用了 delay 函数，delay 函数为一个返回promise 的函数</span><br><span class="line">return yield call(delay, 500)</span><br><span class="line">&#125; catch (err) &#123;</span><br><span class="line">yield put(&#123;type: actionTypes.ERROR&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>fork(fn, …args)<br><code>fork </code>函数和 <code>call</code> 函数很像，都是用来调用其他函数的，但是<code>fork</code>函数是非阻塞函数，也就是说，程序执行完 <code>yield fork(fn， args)</code> 这一行代码后，会立即接着执行下一行代码语句，而不会等待<code>fn</code>函数返回结果后再执行下面的语句，用法：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; fork &#125; from &#x27;redux-saga/effects&#x27;</span><br><span class="line">export default function* rootSaga() &#123;</span><br><span class="line">// 下面的四个 Generator 函数会一次执行，不会阻塞执行</span><br><span class="line">yield fork(addItemFlow)</span><br><span class="line">yield fork(removeItemFlow)</span><br><span class="line">yield fork(toggleItemFlow)</span><br><span class="line">yield fork(modifyItem)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>select(selector, …args)<br><code>select</code> 函数是用来指示 <code>middleware</code>调用提供的选择器获取<code>Store</code>上的<code>state</code>数据，可以简单的把它理解为<code>redux</code>框架中获取<code>store</code>上的 <code>state</code>数据一样的功能 ：<code>store.getState()</code>,用法：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export function* toggleItemFlow() &#123;</span><br><span class="line">// 通过 select effect 来获取 全局 state上的 `getTodoList` 中的 list</span><br><span class="line">let tempList = yield select(state =&gt; state.getTodoList.list)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><H3> 一个具体的实例 </H3><ul><li>index.js<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">import &#123;createStore, applyMiddleware&#125; from &#x27;redux&#x27;</span><br><span class="line">import createSagaMiddleware from &#x27;redux-saga&#x27;</span><br><span class="line">import rootSaga from &#x27;./sagas&#x27;</span><br><span class="line">import Counter from &#x27;./Counter&#x27;</span><br><span class="line">import rootReducer from &#x27;./reducers&#x27;</span><br><span class="line"></span><br><span class="line">const sagaMiddleware = createSagaMiddleware() // 创建了一个saga中间件实例</span><br><span class="line"></span><br><span class="line">// 下边这句话和下边的两行代码创建store的方式是一样的</span><br><span class="line">// const store = createStore(reducers,applyMiddlecare(middlewares))</span><br><span class="line"> </span><br><span class="line">const createStoreWithMiddleware = applyMiddleware(middlewares)(createStore)</span><br><span class="line">const store = createStoreWithMiddleware(rootReducer)</span><br><span class="line">sagaMiddleware.run(rootSaga)</span><br><span class="line"> </span><br><span class="line">const action = type =&gt; store.dispatch(&#123; type &#125;)</span><br><span class="line"> </span><br><span class="line">function render() &#123;</span><br><span class="line"> ReactDOM.render(</span><br><span class="line"> &lt;Counter</span><br><span class="line">  value=&#123;store.getState()&#125;</span><br><span class="line">  onIncrement=&#123;() =&gt; action(&#x27;INCREMENT&#x27;)&#125;</span><br><span class="line">  onDecrement=&#123;() =&gt; action(&#x27;DECREMENT&#x27;)&#125;</span><br><span class="line">  onIncrementAsync=&#123;() =&gt; action(&#x27;INCREMENT_ASYNC&#x27;)&#125; /&gt;,</span><br><span class="line"> document.getElementById(&#x27;root&#x27;)</span><br><span class="line"> )</span><br><span class="line">&#125;</span><br><span class="line">render()</span><br><span class="line">store.subscribe(render)</span><br></pre></td></tr></table></figure></li><li>sagas.js<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; put, call, take,fork &#125; from &#x27;redux-saga/effects&#x27;;</span><br><span class="line">import &#123; takeEvery, takeLatest &#125; from &#x27;redux-saga&#x27;</span><br><span class="line"> </span><br><span class="line">export const delay = ms =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms));</span><br><span class="line"> </span><br><span class="line">function* incrementAsync() &#123;</span><br><span class="line"> // 延迟 1s 在执行 + 1操作</span><br><span class="line"> yield call(delay, 1000);</span><br><span class="line"> yield put(&#123; type: &#x27;INCREMENT&#x27; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">export default function* rootSaga() &#123;</span><br><span class="line"> // while(true)&#123;</span><br><span class="line"> // yield take(&#x27;INCREMENT_ASYNC&#x27;);</span><br><span class="line"> // yield fork(incrementAsync);</span><br><span class="line"> // &#125;</span><br><span class="line"> </span><br><span class="line"> // 下面的写法与上面的写法上等效</span><br><span class="line"> yield* takeEvery(&quot;INCREMENT_ASYNC&quot;, incrementAsync)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>reducer.js<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default function counter(state = 0, action) &#123;</span><br><span class="line"> switch (action.type) &#123;</span><br><span class="line"> case &#x27;INCREMENT&#x27;:</span><br><span class="line">  return state + 1</span><br><span class="line"> case &#x27;DECREMENT&#x27;:</span><br><span class="line">  return state - 1</span><br><span class="line"> case &#x27;INCREMENT_ASYNC&#x27;:</span><br><span class="line">  return state</span><br><span class="line"> default:</span><br><span class="line">  return state</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><H3> redux-saga基本用法总结</H3><ul><li>使用<code>createSagaMiddleware</code>方法创建<code>saga</code>的 <code>Middleware</code> ，然后在创建的 <code>redux</code> 的 <code>store</code> 时，使用 <code>applyMiddleware </code>函数将创建的 <code>saga Middleware </code>实例绑定到 <code>store</code> 上，最后可以调用 <code>saga Middleware</code> 的 <code>run</code> 函数来执行某个或者某些 <code>Middleware</code> 。</li><li>在 <code>saga</code> 的 <code>Middleware</code> 中，可以使用 <code>takeEvery</code> 或者 <code>takeLatest </code>等 <code>API</code> 来监听某个 <code>action</code> ，当某个 <code>action</code> 触发后， <code>saga</code> 可以使用 <code>call</code> 发起异步操作，操作完成后使用 <code>put</code> 函数触发 <code>action</code> ，同步更新 <code>state</code> ，从而完成整个 <code>State</code> 的更新。</li><li><code>ui-&gt;action1(异步请求)-&gt;redux-saga-&gt;action2-&gt;reducer(更新state)</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端基础知识 </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 前端基础知识 </tag>
            
            <tag> React </tag>
            
            <tag> React-redux </tag>
            
            <tag> Redux-saga </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个故事</title>
      <link href="/2021/07/29/%E4%B8%80%E4%B8%AA%E6%95%85%E4%BA%8B/"/>
      <url>/2021/07/29/%E4%B8%80%E4%B8%AA%E6%95%85%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<p>年初的时候在街上的小饭馆里吃饭，注意到有一桌客人在视频，视频中的老妇人大约65岁左右的样子，头发花白，躺在床上行动不便，精神状态也有些不太正常。跟老妇人视频的是一个差不多年纪的大爷，干干瘦瘦的，情绪很是激动，呜呜咽咽地边哭边说。围着老大爷的一对夫妇，其中的妇人也在抹眼泪。出于好奇便跟饭店老板打听了一下。</p><p>饭店老板说老大爷姓牛，原来跟他是一条街上的邻居，去年底刑满释放回来，旁边的夫妇是大爷的妹妹和妹夫，视频中的妇人是大爷的前妻。36年前牛大爷外出打工跟别人打架，打死了人，判了36年，大爷被抓时饭店老板还小，很多事情也是听他父母讲的。牛大爷入狱之后，街上有个混子看孤儿寡母的好欺负，便隔三差五地去骚扰，牛大爷的前妻忍无可忍便报了警，又怕混子出来报复，也是孤儿寡母不好生活，便带着9岁的大女儿、7岁的二女儿、以及3岁的小儿子嫁给了隔壁县的一个村的老光棍。孤儿寡母走了之后，牛大爷的弟弟便把牛大爷的房子卖了，后来在县城里给自己买了房子，前些年查出来得了肺癌，变卖了房子去治病，终究病也没治好，去世了。再说孤儿寡母嫁去隔壁县的第二年牛大爷的前妻便怀孕了，在她坐月子的时候，她现任丈夫带着她4岁的小儿子出去玩耍，回来的时候说孩子掉水里淹死了，她怀疑是现任丈夫杀害了她的小儿子，可也只是怀疑，她本身在坐月子，再加上儿子去世的打击，哭伤了眼睛，早早地眼睛就不行了，后来听说身体状况不是很好，现在已经很难走动了。牛大爷的两个女儿现在都嫁人成家了，也不愿意再认牛大爷。可能成长的过程太过艰辛，无法原谅也不愿再管吧，现在牛大爷只能暂住在妹妹家里。</p><p>听完之后，百感交集，只能长叹一声！</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
          <category> 故事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 故事 </tag>
            
            <tag> 杂文 </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试题--HTML篇(一)</title>
      <link href="/2021/07/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-HTML%E7%AF%87-%E4%B8%80/"/>
      <url>/2021/07/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-HTML%E7%AF%87-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<H3> canvas和svg的区别及各自的应用场景 </H3><ol><li><p><code>canvas</code>是<code>HTML5</code>新增的一个元素对象，名副其实就是一个画布，浏览器<code>js</code>配有相应的操作<code>api</code>，可以不再依赖其他的API或组件而直接绘图，相当于2D的API。一般用于绘制比较复杂的动画，做游戏之类的，由于<code>canvas</code>是<code>HTML5</code>带的，所以不支持低版本浏览器，特别是IE。<code>canvas</code>只是一个画布，绘制上去的东西，例如图片，都是转换成像素点绘制上去的，所以没有<code>event</code>事件，如果需要添加交互事件，需要自己手动计算绘制的对象所在坐标以及层级，还好这部分有第三方库。基本上除了<code>HTML5</code>游戏，一些酷炫的动画，正常的网页交互很少用到。</p></li><li><p><code>svg</code>是一种矢量图形文件格式，图片放大之后不会失真，不仅现在的浏览器都支持，很多主流的系统也都支持。可以代替一些图片,多用于图标,以及图表上,优势在于拥有<code>HTML</code>的event事件,交互起来很方便。</p></li><li><p><code>canvas</code>适用于位图，高数据量高绘制频率（帧率）的场景，如动画、游戏 。<code>svg</code>适用于矢量图，低数据量低绘制频率的场景，如图形、图表、地图等。</p></li><li><p><img src="/img/canvas.png"></p></li></ol><H3> HTML5有哪些新特性，移除了哪些元素 </H3><ol><li><p>新特性：<code>canvas</code>、语义化的标签、<code>localsStorage</code>浏览器关闭 不会丢失、<code>sessionStorage</code>浏览器关闭会自动删除、<code>video/audio</code>、表单控件、<code>websocket</code>、<code>webworker</code>、<code>geolocation</code></p></li><li><p>废除的: <code>&lt;font&gt;</code>、<code>&lt;u&gt;</code>、<code>&lt;basefont&gt;</code>、<code>&lt;big&gt;</code>、<code>&lt;tt&gt;</code>、<code>&lt;cent&gt;</code>、<code>&lt;strike&gt;</code>、<code>&lt;frameset&gt;</code>、<code>&lt;frame&gt;</code>、<code>&lt;noframes&gt;</code></p></li></ol><H3> HTML5的离线存储，解释原理 </H3>用户没有联网的时候，用户可以正常访问站点或应用，联网的时候，更新用户机器上的缓存<ol><li><p>原理：html5离线存储是基于一个.appcache文件的缓存机制，通过这个文件上的解析清单离线存储资源，这些资源会像cookie一样存储下来，之后当网络处于离线状态时，浏览器会通过被离线存储的数据进行页面展示</p></li><li><p>使用：页面头部加一个 manifest的属性，在cache.manifest文件编写离线存储资源，在离线状态时，操作window.applicationCache进行需求实现</p></li></ol><H3> 浏览器是怎么对HTML5的离线存储资源进行管理和加载的 </H3><ol><li><p>在线的情况，浏览器发现页面头部有manifest属性，就会去请求manifest文件，第一次访问app的话，会根据文件里的内容去下载资源并离线存储，如果已经访问过了并且已经离线存储了，会直接使用离线资源加载页面，浏览器对比新旧manifest文件，没有变化的话，不做任何操作，有变化的话，会重新下载并离线存储资源</p></li><li><p>离线的情况，会直接使用离线存储资源</p></li></ol><H3> 行内元素有哪些？块级元素有哪些？空元素有哪些？行内元素和块级元素的区别？</H3><ol><li>行内元素：<code>&lt;span&gt;&lt;img&gt;&lt;input&gt;&lt;select&gt;&lt;b&gt;&lt;a&gt;&lt;strong&gt;</code></li><li>块级元素：<code>&lt;div&gt;&lt;p&gt;&lt;ul&gt;&lt;h&gt;&lt;li&gt;&lt;ol&gt;&lt;dl&gt;&lt;dd&gt;&lt;tt&gt;&lt;dt&gt;</code></li><li>空元素：<code>&lt;br&gt;&lt;hr&gt;&lt;link&gt;&lt;meta&gt;</code></li><li>区别：行内元素不占宽高，不独占一行，块级元素占宽高，独占一行</li></ol><H3> HTML全局属性有哪些 </H3><ol><li>class—设置全局类标志</li><li>id—全局唯一id</li><li>style—行内css样式</li><li>lang—元素内容的语言</li><li>data-*—添加自定义属性</li><li>draggable—元素是否可拖拽</li><li>title—元素相关的信息建议</li></ol><H3> sessionStorage、localStorage、cookie的区别 </H3><ol><li><code>cookie</code>用于标记用户身份存在用户本地客户端，会随着<code>http</code>请求在客户端和服务器端来回传递</li><li><code>sessionStorage</code> 和 <code>localStorage</code>只存在客户端 不会在服务端传递</li><li><code>cookie</code>的存储大小不大于4k，<code>localStorage和sessionStorage</code>存储大小可以到5M</li><li><code>cookie</code>在过期时间内不会消失， <code>localStorage</code>不会随着浏览器关闭而消失，<code>sessionStorag</code>浏览器关闭会消失</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端面试题 </category>
          
          <category> HTML(HTML5)篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端面试题 </tag>
            
            <tag> 前端 </tag>
            
            <tag> 前端基础知识 </tag>
            
            <tag> HTML </tag>
            
            <tag> HTML5 </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试题--CSS篇(一)</title>
      <link href="/2021/07/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-CSS%E7%AF%87-%E4%B8%80/"/>
      <url>/2021/07/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-CSS%E7%AF%87-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<H3> px、em和rem的区别 </H3><ol><li><p>px：像素（Pixel），相对长度单位。它不随其它元素的变化而变化。</p></li><li><p>em：相对长度单位，相对于当前对象内文本的字体尺寸。任意浏览器的默认字体高都是16px，所以未经调整的浏览器都符合: <code>1em=16px</code>。<br>它的特点是：它的值并不是固定的；它会继承父级元素的字体大小。例如:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div style=&quot;font-size:20px;&quot;&gt;</span><br><span class="line">    &lt;p style=&quot;font-size:1em;&quot;&gt;这里1em=20px&lt;/p&gt;</span><br><span class="line">    &lt;p style=&quot;font-size:2em;&quot;&gt;这里2em=40px&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>上面的例子就说明了<code>em</code>的值并非固定的，他是根据父元素的字体大小来决定的。如果父元素设置了<code>font-size:20px</code>，那么<code>1em=20px</code>，<code>2em=40px</code>；如果父元素设置了<code>font-size:30px</code>，那么<code>1em=30px</code>，<code>2em=60px</code>。依次类推。</p></li><li><p>rem：是<code>CSS3</code>新增的一个相对单位，它的值并不是固定的，但相对的只是<code>HTML</code>根元素。任意浏览器的默认字体高都是<code>16px</code>，所以未经调整的浏览器都符合: <code>1rem=16px</code>。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html style=&quot;font-size:100px;&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">     &lt;p style=&quot;font-size:1rem;&quot;&gt;这里1rem=100px&lt;/p&gt;</span><br><span class="line">     &lt;div style=&quot;font-size:50px;&quot;&gt;</span><br><span class="line">          &lt;p style=&quot;font-size:2rem;&quot;&gt;这里2rem=200px&lt;/p&gt;</span><br><span class="line">     &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>上面的例子说明了，<code>rem</code>的值只受到根节点<code>html</code>的字体大小影响，并不受父元素字体大小的影响。如果根节点<code>html</code>设置了<code>font-size:100px</code>，那么<code>1rem=100px，2rem=200px</code>；如果根节点<code>html</code>设置了<code>font-size:200px，那么1rem=200px，2rem=400px</code>。依次类推。</p></li></ol><p>注意：<br>谷歌浏览器chrome强制最小字体为<code>12px</code>，因此即使设置了小于<code>12px</code>的值，也会显示成<code>12px</code>。因此，当你给<code>html</code>设置<code>font-size:10px</code>时，<code>1rem</code>并不是等于<code>10px</code>，而是等于<code>12px</code>。</p><H3> 垂直居中的方法 </H3><ol><li><p>flex + margin (强烈推荐)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.outer &#123;</span><br><span class="line">    display: flex;</span><br><span class="line"> &#125;</span><br><span class="line">.inner &#123;</span><br><span class="line">    background: silver;</span><br><span class="line">    margin: auto;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;div class=&quot;outer&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;inner&quot;&gt;test&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>flex</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.outer &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center;</span><br><span class="line"> &#125;</span><br><span class="line">.inner &#123;</span><br><span class="line">    background: silver;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;div class=&quot;outer&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;inner&quot;&gt;test&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>translate</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.outer &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.inner &#123;</span><br><span class="line">    background: silver;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 50%;</span><br><span class="line">    left: 50%;</span><br><span class="line">    transform: translate(-50%,-50%);</span><br><span class="line">    text-align: center;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;div class=&quot;outer&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;inner&quot;&gt;test&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>display:inline-block结合:after</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.outer &#123;</span><br><span class="line">    text-align:center;</span><br><span class="line"> &#125;</span><br><span class="line">.inner &#123;</span><br><span class="line">    background: silver;</span><br><span class="line">    display:inline-block;</span><br><span class="line"> &#125;</span><br><span class="line"> .outer:after&#123;</span><br><span class="line">    content:&#x27;&#x27;;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;div class=&quot;outer&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;inner&quot;&gt;test&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>display:-webkit-box</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.outer &#123;</span><br><span class="line">    display: -webkit-box;</span><br><span class="line">    -webkit-box-pack:center;</span><br><span class="line">    -webkit-box-align:center;</span><br><span class="line">    -webkit-box-orient: vertical;</span><br><span class="line">    text-align: center</span><br><span class="line"> &#125;</span><br><span class="line">&lt;div class=&quot;outer&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;inner&quot;&gt;test&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ol><p>好了，方法还是很多的，大家择优选择吧！</p><H3> BFC 及其应用 </H3><ol><li><p>BFC 概念<br>BFC 就是块级格式上下文，是页面盒模型布局中的一种<code>CSS</code>渲染模式，具有<code>BFC</code>特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且<code>BFC</code>具有普通容器所没有的一些特性。</p></li><li><p>创建 BFC 的方式及作用</p><ul><li>创建 BFC 的方式有：<ul><li>body 根元素</li><li>浮动元素：float 除 none 以外的值</li><li>绝对定位元素：position (absolute、fixed)</li><li>display 为 inline-block、table-cells、flex</li><li>overflow 除了 visible 以外的值 (hidden、auto、scroll)</li></ul></li><li>BFC 主要的作用是：<ul><li>清除浮动</li><li>防止同一 BFC 容器中的相邻元素间的外边距重叠问题</li></ul></li></ul></li><li><p>BFC 特性及应用</p><ul><li><p>同一个 BFC 下外边距会发生折叠</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">div&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: lightblue;</span><br><span class="line">    margin: 100px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>因为两个<code>div</code>元素都处于同一个<code>BFC</code>容器下 (这里指<code>body</code>元素) ，所以第一个<code>div</code>的下边距和第二个<code>div</code>的上边距发生了重叠，所以两个盒子之间距离只有<code>100px</code>，而不是<code>200px</code>。首先这不是<code>CSS</code>的bug，我们可以理解为一种规范，如果想要避免外边距的重叠，可以将其放在不同的<code>BFC</code>容器中。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">p &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: lightblue;</span><br><span class="line">    margin: 100px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这个时候两个<code>div</code>的边距就是<code>200px</code>了</p></li><li><p>BFC 可以包含浮动的元素（清除浮动）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div style=&quot;border: 1px solid #000;&quot;&gt;</span><br><span class="line">    &lt;div style=&quot;width: 100px;height: 100px;background: #eee;float: left;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>浮动的元素会脱离普通文档流，由于容器内元素浮动，脱离了文档流，所以容器只剩下<code>2px</code>的边距高度。如果触发容器的<code>BFC</code>，那么容器将会包裹着浮动元素。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div style=&quot;border: 1px solid #000;overflow: hidden&quot;&gt;</span><br><span class="line">    &lt;div style=&quot;width: 100px;height: 100px;background: #eee;float: left;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>BFC 可以阻止元素被浮动元素覆盖</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div style=&quot;height: 100px;width: 100px;float: left;background: lightblue&quot;&gt;我是一个左浮动的元素&lt;/div&gt;</span><br><span class="line">&lt;div style=&quot;width: 200px; height: 200px;background: #eee&quot;&gt;我是一个没有设置浮动, </span><br><span class="line">也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这时候其实第二个元素有部分被浮动元素所覆盖(但是文本信息不会被浮动元素所覆盖) ，如果想避免元素被覆盖，可触发第二个元素的<code>BFC</code>特性，在第二个元素中加入<code>overflow: hidden</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div style=&quot;height: 100px;width: 100px;float: left;background: lightblue&quot;&gt;我是一个左浮动的元素&lt;/div&gt;</span><br><span class="line">&lt;div style=&quot;width: 200px; height: 200px;background: #eee&quot;; overflow: hidden&gt;我是一个没有设置浮动, </span><br><span class="line">也没有触发BFC元素, width: 200px; height:200px; background: #eee;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这样就可以用来实现两列自适应布局，这时候左边的宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度)。</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端面试题 </category>
          
          <category> CSS篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端面试题 </tag>
            
            <tag> 前端 </tag>
            
            <tag> 前端基础知识 </tag>
            
            <tag> CSS </tag>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路(三)</title>
      <link href="/2021/07/28/%E8%B7%AF-%E4%B8%89/"/>
      <url>/2021/07/28/%E8%B7%AF-%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<p>哥哥走后，弟弟便承担起了照顾两个家庭的责任，随着年岁增加，弟弟也到了议亲的年纪，两家的父母希望弟弟跟哥哥的亲生妹妹结秦晋之好，这样两家就顺理成章可以成为真正意义上的一家人了，弟弟自然不会反对，他从小就擅于照顾妹妹，妹妹自然是父母之命，媒妁之言。这样就在弟弟18岁的时候，两家结亲了，宴请了村子里的所有人，说是宴请倒也不如说是全村人一起出物出力帮他们办了这场酒筵。婚后两家的矮墙也彻底清除了，年轻夫妇日出而作，日落而息，倒也过着琴瑟和鸣的日子，长辈们也和和气气，一家人其乐融融，唯一的缺憾就是哥哥不在，也不知道在外面过的怎么样。夏季雨水本来就多，这天雨一直没听过，自然也不能出门干活，夫妻俩在家闲聊，自然也聊到了哥哥，妻子说她以为当初丈夫会跟着哥哥一起出门呢，后来听说丈夫不会去的时候，好生开心，顺道就问了丈夫当初为什么没离开。丈夫边编着箩筐边说道他当初进学堂学习的时候，听先生讲多了官场的事迹，本身就不喜欢当官，其次对先生教的东西没信心，也对自己没信心能干出一番事业，再者总要有个人要照顾家里的，既然哥哥打定主意要出去闯荡，那自己就留在家里也未尝不可。听罢丈夫的一番话，妻子更是对丈夫心生怜爱，从来不知道丈夫有这么多心事没说，心里暗想以后一定要多跟丈夫聊天，对他更好一些。转眼已经成亲两年了，日子也就这样平平淡淡地过着，没有一丝波澜，唯一的波澜便是已经成亲两年了，但是也不见妻子的肚子有动静，这不免让婆婆有些许微言，但是每次丈夫都能圆回去，也就罢了。</p><p>在京城的哥哥自然是不知道家里发生的事情，也不知道弟弟已经成亲了，离开饭庄的这两年在街上摆过摊替人写过书信，依旧参加了各种考试，但是一种从心底油然而生的无力感也使得他渐渐意识到自己的目标终究是黄粱一梦，每天靠着干点零活糊口，每逢过节的时候更是加深了他回家的念头，但是想到自己这几年一事无成，自尊心作祟，回家的念头也就打消了。这些年不是没有喜欢的姑娘，但是即便对方是普通人家的女孩，人家父母也看不上一个孤身一人的穷小子，只得作罢。就在他混沌度日的时候，传来一个消息，说是京城里有一家员外郎娶了多房小妾，依旧没有生出儿子来，膝下只有3个女儿，如今员外郎年纪大了，也不指望能生出儿子来了，只想着招上门女婿，待他日生下儿子继承家业，招上门女婿的条件倒也不苛刻，只需生的俊秀（基因要好），孤身一人（方便控制），能识文断字（要跟小姐有的聊），当然最重要的是跟自己女儿的八字要和，也不克老丈人。在哥哥的认知里，读书人是断断不能入赘的，有辱斯文，但是连续的挫折、目前的穷困生活以及对那个梦莫名的相信以及执着，让他动了入赘的念头，在良久的心理建设之后，哥哥决定去试试。</p><p>既已决定去试试，哥哥便去了员外府，一番简单的盘查之后，就让哥哥写了八字留下，回家等待合八字的结果。走出员外府的时候哥哥心里慌张了起来，因为刚才员外盘查哥哥的家世时，哥哥说谎了，他说他本是读书人家的孩子，但是家里招了灾，饿死了一家老小，只有他活了下来，哥哥说谎的理由很简单，就是想着能早点入赘员外家。但毕竟是第一次说谎，多少有点紧张，但事到如今已经没有退路了，只能硬着头皮扛下去。没过几天便传来了消息，说是可以入赘了，他什么都不用管，只需过去员外府等着拜堂成亲。顺理成章地哥哥成亲了，所幸的是，员外千金是真正的闺阁小姐，知书达理，倒也算是一桩不错的姻缘，日子也这样过了下去，除了平时要看别人的白眼，日子倒也平顺，很快小姐怀孕了，怀胎十月生下了一个大胖小子，员外高兴坏了，开棚施粥、寺庙布施样样少不了，员外对哥哥也是越看越顺眼。哥哥在员外府的日子过的不错，自然又是想起了家里，因为之前说家里都没人了，也对家人愈发的愧疚，再加上现在手里有了点钱，就更想回家看看了。他不知道的是村里也发生了变化，新上任的知府无意间知道了幸福村山里有丰富的矿产，便上报朝廷要给幸福村修桥，一方面是方便矿产出山，另一方面也是利民的好事，朝廷自然是拨款同意，就这样幸福村的桥就修了起来，整整修了两年，一条不算宽阔的桥修了起来，幸福村的人民也因为意外发现的矿产富裕了许多。这时候家里人想起了已经离家6年的哥哥，思念这种东西，一起唤起便无法抑制，尤其是老人，弟弟便决定自己去京城找哥哥，找得到最好，找不到的话便回来骗父母说哥哥过的很好，不必太过思念。不日，弟弟便动身出发去找哥哥了，弟弟是坐马车去的京城，用的时间自然是比哥哥要短，赶在七夕前弟弟便到了京城，京城的繁华自然也晃了弟弟的眼睛，但麻烦的是偌大个京城怎么找哥哥呢，毫无头绪，只能先住下来打听打听，弟弟便先住在了客栈，客栈伙计跟弟弟说明天是七夕节，傍晚会有放花灯活动，人肯定是找不到了，因为到处是人，但是可以看看京城的花灯活动也不为一件乐事。听罢伙计的话，弟弟更沮丧了，但也没办法，只能走一步看一步。</p><p>次日，街上果真人山人海，热闹非凡，弟弟在街上闲逛，边走边思考该如何找哥哥，走着走着边走到员外府门外，好巧不巧，他看到了一个人，虽然跟以前不一样了，但是赫然就是哥哥呀。他开心地叫着小时候叫哥哥的昵称，哥哥听到后也高兴坏了，他忘记了他周围的员外、妻子以及刚满一岁的儿子，冲向了弟弟，兄弟俩激动地拥抱着，述说这彼此的想念。他完全没有注意到员外阴沉的脸以及妻子担忧的神情，等他回过神来的时候，才意识到自己有大麻烦了。他决定坦白，他以为他都有孩子了，员外会看在孩子的面子上原谅他，接受他，以后自己也可以堂堂正正地去见家里人了。但是现实中没有那么多我以为、他以为、你以为，只有手握权利的人的以为，结局自然便是员外不能接受哥哥的欺骗、也不能接受哥哥的家人、更重要的是已经有儿子了，不再需要一个欺骗了自己的人，任凭自己女儿怎么哀求，员外还是坚持要把哥哥赶走。弟弟看到哥哥如今的处境便明白了哥哥这些年的苦楚，同时自己的到来又给哥哥惹了这么多的麻烦，更是心疼哥哥。员外是不可能接受哥哥了，当初成亲的时候哥哥可是签了契约的，如今这个局势，哥哥只能离开员外府了，只是可惜了孩子及妻子。哥哥虽然想到了可能会有这么一天，只是没想到事到临头了才发现原来还是这么难过。看到哥哥这个样子，弟弟便决定带哥哥回家，哥哥也经过了这么多事情后发现原来诺大个京城一直没有他的立身之地，心灰意冷之下跟着弟弟回家了，终究也没感受到张灯结彩，人声鼎沸的花灯节。</p><p>回家的路上弟弟陆续跟哥哥说了这些年家里的变化，以及他成亲了、村里修桥了之类的事情。听到这些哥哥虽然看着是开心的，但是弟弟明显能感受到哥哥的落寞，哥哥已经不是从前那个积极、乐观、傲气的哥哥了。终于在入秋的时候，弟弟带着哥哥回家了，虽然听弟弟讲了修桥的事情，但真正看到桥的时候，才豁然发现自己真的回来了，回到了梦里想了无数次的家，一路回家之后，自然是哭声一片，但这是喜悦的哭泣，是思念的倾诉，也是团圆的号角。哥哥在外面的事情自然是不能告诉家里人的，在幸福村里只有天知地知兄弟俩知。但是家人们也明显能感受到哥哥的变化，感觉清冷了很多，不像是以前那个话多的哥哥了，自然也就知道了哥哥这些年在外面没少吃苦，又是一阵心疼。在家待了几天后，哥哥的心情开阔了许多，也想明白了一些事情，不再执着于成就、功名这些虚渺的东西，想到以前装牛角尖的自己便觉得傻的可以，同时也觉得自己把书读迂腐了，便重新修建了学堂，立志这辈子要好好教书育人，真正意义上的教书育人，家里人自然是开心的。只是令家里人发愁的是哥哥立志一辈子不娶，而弟弟呢成亲这么年了一直没有所出，难道是要让他们绝后吗，殊不知不孝有三，无后为大，所以家里人便一直张罗着给儿媳妇吃各种补药，希望能有一儿半女。。。。。。</p><p>注：取名为路的原因如下：一、是因为幸福村没路所以哥哥更向往外面的世界，才引出了下面的故事；二、路也揭示着哥哥和弟弟选择的不同的人生之路</p><p>本文完！</p>]]></content>
      
      
      <categories>
          
          <category> 小说 </category>
          
          <category> 路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 故事 </tag>
            
            <tag> 小说 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路(二)</title>
      <link href="/2021/07/28/%E8%B7%AF-%E4%BA%8C/"/>
      <url>/2021/07/28/%E8%B7%AF-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p>哥哥顺利地进城了，一进京城，他就被京城的繁华震惊了，走在大街上他觉得京城里的人也更漂亮，建筑也更好看，一切一切都那么美好，就这样走了好久，直到肚子咕咕叫的时候，他才意识到没钱吃东西，要想办法解决吃饭以及睡觉的问题。他突然就想到了那个梦，他人生地不熟也不知道去哪里找将军府邸，但书里写过，但凡是富贵人家必定是高门大户，那就一户一户地去看看吧，总会找到的，他这么安慰自己的时候，感觉肚子倒也不是那么饿了，这强大的信念呵！就这样找来找去，太快黑的时候终于让他找到了一个显赫的府邸，但不是将军府，门厅上赫然写着三个大字“公主府”，但是堂堂公主府岂是那么容易进的，结局可想而知，哥哥在街角蹲了一晚上，秋天的夜晚虽然不算太冷，但是又饿又冷毕竟还是难捱，但总算是天亮了，又是充满希望的一天。</p><p>次日，哥哥意识到这样不行，还没找到将军府呢就会被饿死，首先要先找一个落脚的地方，先要有饭吃，怀着这样的心情，哥哥踏上了找工作的路程。想到自己的一肚子学问，哥哥的首选工作是府衙文书，但是文书是要正式考取的，现在已经过了考试时间，要等明年才可以。其次是学堂先生，但是京城里的学堂先生也不是随便什么人都可以当的。最后为了糊口，哥哥不得不去了一家饭庄打杂，好在饭庄老板看哥哥不像是什么不好相处的人，而且又是一个饥肠辘辘的外乡人，方便少给工钱，几番周折之后，哥哥终于吃上了热呼呼的饭，心里也不免好生感概了一番。</p><p>就这样算是在这里安定了下来，虽然一天下来累的要死，但是好在有口饭吃，有地方睡觉，也算是一个进步。日子这样过着，虽然刚开始不习惯饭庄的生活，但是一个月下来，除了累，倒也习惯了，看着领到手的工钱，哥哥觉得自己来京城的目的跟现在的生活相差甚远，再想起家里的弟弟和亲人，不免更加忧虑急躁起来，想着干满3个月，一定要换一个离目标近的工作。所以接下来的日子，哥哥一边在酒庄干活，一边打听哪里需要幕僚，在酒庄干活的好处就是可以接触到各形各色的人，打听起消息来也更加方便，经过多方打听，终于等来了一个机会，说是真有一个新贵将军入驻京城，将军府招募文书，最重要一条是家底干净，写的一手好文章，哥哥喜出望外，这无疑是最近听来的最好的一条消息了，暗暗发誓一定要拿下，这样的机会可不是每天都有。次日，他便偷偷溜出去到了将军府报名考试，原来已经有很多人在排队了，经过简单的填表信息之后，就直接进入了考试环节，首先是考察文笔，以“论做官之道”为题作一篇文章，哥哥心花怒放，这个为官之道，先生交了好多遍，自然是笔到文来，心里好生得意了一番。接下来是一个简单的问答考试，考察的是实际应变能力。考完之后就让大家回去了，说是3天后会通知大家结果，哥哥自问答的不错，高高兴兴地会饭庄去了，虽然回去的时候被饭庄老板责骂了一顿，但想到美好的未来自也没说什么，麻利地干活去了。转眼3天过去了，等了一天也没等到人来通知他，再次偷偷溜去了将军府，一问才知道录用名单上没有他，调了卷宗给他看，上面的判词写道：年资甚浅、书生意气、不录。看罢心情一落千丈，再想到离家已近一年，还是一个打杂的，前路甚是渺茫，就更难过了，垂头丧气地回到了饭庄，又是一顿责骂。</p><p>转眼两年过去了，两年来哥哥一直在饭庄干活，期间也去试了各种招考，但每次都没过，现在相较两年前刚来京城的时候，气性已经被磨了不少。18岁的大小伙了，也不能一直在饭庄打杂，但是又找不到适合自己做的事情，两年了挣的钱也不多，深夜的时候一个人就会想家里人，甚至后悔当初莽撞出来了，外面的世界虽然精彩但是也很无奈。可是终究也还是心存希望，觉得还可以再等等，说不定再等等，就可以了，抱着这样的心态，倒也可以安心入睡了。好景不长，饭庄由于不景气，已经用不了这么多人了，老板要遣散人员，哥哥在名单之中。这一下，哥哥又开始了流浪的日子。。。</p><p>未完待续。。。。。。</p>]]></content>
      
      
      <categories>
          
          <category> 小说 </category>
          
          <category> 路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 故事 </tag>
            
            <tag> 小说 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路(一)</title>
      <link href="/2021/07/28/%E8%B7%AF-%E4%B8%80/"/>
      <url>/2021/07/28/%E8%B7%AF-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>很久很久以前，在大山深处有一个叫幸福村的小村子，由于出入村子的通道只有一条索道，只有需要买卖东西的时候，村里的年轻人才会出去，所以村子里的人很少与外人接触，倒也过的自由自在，民风也甚是淳朴。</p><p>村里有一个读书人，年轻的时候，一心想着入仕上报国家，下效人民。苦读多年后终于成为了一名幕僚，怎奈读书人性格难以融入幕僚生活，心灰意冷亦或是认清现实后，回村子里成为了一名教书先生，一方面是以此糊口，再者也是希望能培养一个完成他理想的人。村子里的学堂不大，学生只有7、8个，故事就是从这两个学生展开的。</p><p>学堂里的学生本身就不多，其中有两个男孩子的年龄偏大，约莫十岁左右，偏巧他们两家是邻居，所以经常一起上下学、一起干活，亲如兄弟。他们两家仅隔了一堵矮墙，一探头就可以看到彼此的院子，两家的日子过的紧巴巴的，但是只要一方猎到野味，都会叫对方一起吃饭。每逢遇集的时候，那是最开心的了，这个时候兄弟二人会跟着村里的人爬索道去外面把家里编织的箩筐、猎物的皮毛换成钱或者生活用品，他们虽然羡慕着镇子里的繁荣，但却更加坚信十年寒窗苦读定会让他们走出大山，见识比镇子更大的世界，走在镇子上的两人倒也更坦然了，放佛他们已经见到了更宽广的世界，这大概就是信念的力量吧。村子里的日子日复一日，倒也没有多大的变化，唯一变化的可能就是变化本身了，当然兄弟俩也在圣贤书的熏陶下，愈发的有礼谦逊。出生月份大一点的哥哥从小性格就比弟弟要活跃一些，爱表现自己一些，弟弟则比较沉默安静，这么多年性格都也没变。前一年冬天的时候，教书先生受了风寒病倒了，一直也不见好，开春的时候，眼看着气色有点好转，结果清明的时候就不行了，在告诫了兄弟二人读书人的使命与气节之后就永远地闭上了眼睛。教书先生去世之后，自然也没有了学堂，入夏的一天，兄弟二人躺在院子里的草垛上看着天上的繁星聊天，聊对未来的想法。不知道是没有想法还是不想说自己的想法，弟弟一直也没有表达自己想法，说是聊天，但其实只有哥哥在说，哥哥说他一直想去村子外面的世界看看，人活一辈子不能把自己困在这小小的四方天地，那也就枉费了他读这么多年的圣贤书了，既然现在先生不在了，那可能就是上天给他的一个信号，他过两天就要离开村子去外面闯荡了。问弟弟愿不愿意跟他一起走，弟弟说要考虑考虑，哥哥这个时候已经明白了弟弟应该是不愿意随他一起离开。</p><p>到了约定的时间，弟弟送哥哥去了索道旁，哥哥就独自离开了村子，嘱托弟弟帮忙照顾自己的父母家人，弟弟依旧简短地说了让哥哥放心之类的话。哥哥跟弟弟说等他有了功名，第一件事就是帮村里修路，修一条让男女老少都可以走出村子的路，哥哥说相信他，一定不会很久的，说完哥哥就溜着索道走了，弟弟在索道旁站了好久，直到看不到哥哥的身影才缓缓离开。哥哥走出村子到了镇子里，全身上下只有一个小包袱和家里攒的一小串铜板，哥哥知道自己要去的路还长，就加快了前进的步伐，依靠着心里的信念以及路上人的帮助，走了数月之后，哥哥终于身无分文到了京城。赶到京城的时候天已经黑了，城门已经关了，想要省点钱的外乡人都会聚集在离城门不远的破庙里度过一晚，当然有钱的人自然是会去住店，哥哥也去了破庙，在破庙了他做了一个梦，梦里他一到京城就当上了将军府的幕僚，在将军府混的风生水起，迎娶了一个千金小姐，还入朝见到了皇上，官拜一品，随即他就下令给村子里修了一条路，那是多么宽敞的一条路啊，可是为什么看不到家人呢，为什么看不到弟弟了呢，瞬间他就惊醒了，才发现天蒙蒙亮了，原来是做了一场梦，他理了理思绪，觉得这个梦也许是老天爷给他的一个信号，他一定能干出一番事业来，想到这里，难以抑制的兴奋也使他没法入睡了，索性就起来朝城门走去。。。。。。</p><p>未完待续。。。。。。</p>]]></content>
      
      
      <categories>
          
          <category> 小说 </category>
          
          <category> 路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 故事 </tag>
            
            <tag> 小说 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试题--JS篇(一)</title>
      <link href="/2021/07/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-Js%E7%AF%87-%E4%B8%80/"/>
      <url>/2021/07/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-Js%E7%AF%87-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<H3> 变量类型的判断 </H3><p>JS中常见的数据类型分为基本类型：<code>string、boolean、number、undefined、null、symbol(ES6)</code>和引用类型：<code>Object</code></p><ol><li><p>判断js数据类型最常用的是<code>typeof</code>，使用它会返回一个字符串，适合函数对象（function）和基本类型（js中的基本类型：<code>number、string、boolean、null、undefined、symbol、object</code>［对象］）的判断，例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(typeof 1);</span><br><span class="line">console.log(typeof &quot;str&quot;);</span><br><span class="line">console.log(typeof false);</span><br><span class="line">console.log(typeof null);</span><br><span class="line">console.log(typeof undefined);</span><br><span class="line">console.log(typeof function()&#123;&#125;);</span><br><span class="line">console.log(typeof new Object());</span><br><span class="line">console.log(typeof new Array());</span><br><span class="line">console.log(typeof [1,2,3]);</span><br><span class="line">console.log(typeof Symbol());</span><br></pre></td></tr></table></figure><p>结果为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">number</span><br><span class="line">string</span><br><span class="line">boolean</span><br><span class="line">object</span><br><span class="line">undefined</span><br><span class="line">function</span><br><span class="line">object</span><br><span class="line">object</span><br><span class="line">object</span><br><span class="line">symbol</span><br></pre></td></tr></table></figure><p>那么问题来了，如果想要判断一个对象是不是数组，使用<code>typeof</code>就会返回一个<code>object</code>，这时候就要使用<code>instanceof</code>来判断对象类型了</p></li><li><p><code>instanceof</code>操作符<br><code>obj instanceof Object</code>，左边操作数<code>obj</code>为对象（如果不小心写成基本类型 比如数字啥的，就会返回<code>false</code>），右边操作数<code>Object为</code>函数对象或者是函数构造器，否则抛出<code>TypeError</code>。<br>实质就是：<code>instanceof</code>操作符判断左操作数对象的原型链上是否有右边这个构造函数的<code>prototype</code>属性，也就是说指定对象是否是某个构造函数的实例，最后返回布尔值，这个对整个原型链上的对象都是有效的，由于<code>instanceof</code>对整个原型链上的对象都有效，因此同一个实例对象，可能会对多个构造函数都返回<code>true</code>！</p></li><li><p><code>Object.prototype.toString</code>方法<br>直接上例子，如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(Object.prototype.toString.call([]));</span><br><span class="line">console.log(Object.prototype.toString.call(&#123;&#125;));</span><br><span class="line">console.log(Object.prototype.toString.call(1));</span><br><span class="line">console.log(Object.prototype.toString.call(false));</span><br><span class="line">console.log(Object.prototype.toString.call(Symbol()));</span><br><span class="line">console.log(Object.prototype.toString.call(&#x27;str&#x27;));</span><br><span class="line">console.log(Object.prototype.toString.call(null));</span><br><span class="line">console.log(Object.prototype.toString.call(undefined));</span><br><span class="line">console.log(Object.prototype.toString.call(function()&#123;&#125;));</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[object Array]</span><br><span class="line">[object Object]</span><br><span class="line">[object Number]</span><br><span class="line">[object Boolean]</span><br><span class="line">[object Symbol]</span><br><span class="line">[object String]</span><br><span class="line">[object Null]</span><br><span class="line">[object Undefined]</span><br><span class="line">[object Function]</span><br></pre></td></tr></table></figure></li></ol><p>综上，判断的方法还有多种，但是有这三种也就够了，第三种胜在通用，但是拼写麻烦，也可以考虑第一种和第二种配合使用，这里提供一个完整的函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getType(data) &#123;</span><br><span class="line">    let type = typeof data;</span><br><span class="line">    if (type !== &#x27;object&#x27;) &#123;</span><br><span class="line">        return type</span><br><span class="line">    &#125;</span><br><span class="line">    return Object.prototype.toString.call(data).replace(/^\[object (\S+)\]$/, &#x27;$1&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(getType(() =&gt; &#123;&#125;)); //function</span><br></pre></td></tr></table></figure><H3> 前端去重的方法 </H3><ol><li><p>利用<code>ES6 Set</code>去重（ES6中最常用）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function unique (arr) &#123;</span><br><span class="line">    //Set数据结构，它类似于数组，其成员的值都是唯一的</span><br><span class="line">    return Array.from(new Set(arr)); // 利用Array.from将Set结构转换成数组</span><br><span class="line">&#125;</span><br><span class="line">var arr = [1, &#x27;1&#x27;, 1, &#x27;1&#x27;, NaN, &#x27;NaN&#x27;, NaN, &#123;a: 1&#125;, &#x27;&#123;a: 1&#125;&#x27;, &#123;a: 1&#125;, undefined, undefined,  null, null, &#x27;undefined&#x27;, &#x27;null&#x27;, &#x27;undefined&#x27;, &#x27;null&#x27;];</span><br><span class="line">//[1, &#x27;1&#x27;, NaN, &#x27;NaN&#x27;, &#123;a: 1&#125;, &#x27;&#123;a: 1&#125;&#x27;, &#123;a: 1&#125;, undefined, null, &#x27;undefined&#x27;, &#x27;null&#x27;]</span><br></pre></td></tr></table></figure><p>不考虑兼容性，这种去重的方法代码最少，但是无法去掉<code>&quot;&#123;a: 1&#125;&quot;</code>对象</p></li><li><p>利用<code>for</code>嵌套<code>for</code>，然后<code>splice</code>去重（ES5中最常用）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function unique(arr)&#123;            </span><br><span class="line">    for(var i=0; i&lt;arr.length; i++)&#123;</span><br><span class="line">        for(var j=i+1; j&lt;arr.length; j++)&#123;</span><br><span class="line">            if(arr[i]===arr[j])&#123;         //第一个等同于第二个，splice方法删除第二个</span><br><span class="line">                arr.splice(j,1);</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">return arr;</span><br><span class="line">&#125;</span><br><span class="line">var arr = [1, &#x27;1&#x27;, 1, &#x27;1&#x27;, NaN, &#x27;NaN&#x27;, NaN, &#123;a: 1&#125;, &#x27;&#123;a: 1&#125;&#x27;, &#123;a: 1&#125;, undefined, undefined,  null, null, &#x27;undefined&#x27;, &#x27;null&#x27;, &#x27;undefined&#x27;, &#x27;null&#x27;];</span><br><span class="line">//[1, &#x27;1&#x27;, NaN, &#x27;NaN&#x27;, NaN, &#123;a: 1&#125;, &#x27;&#123;a: 1&#125;&#x27;, &#123;a: 1&#125;, undefined, null, &#x27;undefined&#x27;, &#x27;null&#x27;]</span><br></pre></td></tr></table></figure><p>无法去除<code>NaN</code>和``{a: 1}<code>对象，因为</code>NaN === NaN和{a: 1} === {a: 1}` 不成立</p></li><li><p>利用<code>indexOf</code>去重 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    if (!Array.isArray(arr)) &#123;</span><br><span class="line">        console.log(&#x27;type error&#x27;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    var array = [];</span><br><span class="line">    for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (array.indexOf(arr[i]) === -1) &#123;</span><br><span class="line">           array.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br><span class="line">var arr = [1, &#x27;1&#x27;, 1, &#x27;1&#x27;, NaN, &#x27;NaN&#x27;, NaN, &#123;a: 1&#125;, &#x27;&#123;a: 1&#125;&#x27;, &#123;a: 1&#125;, undefined, undefined,  null, null, &#x27;undefined&#x27;, &#x27;null&#x27;, &#x27;undefined&#x27;, &#x27;null&#x27;];</span><br><span class="line">//[1, &#x27;1&#x27;, NaN, &#x27;NaN&#x27;, NaN, &#123;a: 1&#125;, &#x27;&#123;a: 1&#125;&#x27;, &#123;a: 1&#125;, undefined, null, &#x27;undefined&#x27;, &#x27;null&#x27;]</span><br></pre></td></tr></table></figure><p>无法去除<code>NaN</code>和<code>&#123;a: 1&#125;</code>对象</p></li><li><p>利用<code>includes</code>去重</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    if (!Array.isArray(arr)) &#123;</span><br><span class="line">        console.log(&#x27;type error&#x27;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    var array = [];</span><br><span class="line">    for (var i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (!array.includes(arr[i])) &#123;</span><br><span class="line">           array.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br><span class="line">var arr = [1, &#x27;1&#x27;, 1, &#x27;1&#x27;, NaN, &#x27;NaN&#x27;, NaN, &#123;a: 1&#125;, &#x27;&#123;a: 1&#125;&#x27;, &#123;a: 1&#125;, undefined, undefined,  null, null, &#x27;undefined&#x27;, &#x27;null&#x27;, &#x27;undefined&#x27;, &#x27;null&#x27;];</span><br><span class="line">//[1, &#x27;1&#x27;, NaN, &#x27;NaN&#x27;, &#123;a: 1&#125;, &#x27;&#123;a: 1&#125;&#x27;, &#123;a: 1&#125;, undefined, null, &#x27;undefined&#x27;, &#x27;null&#x27;]</span><br></pre></td></tr></table></figure><p>没有去除<code>&#123;a: 1&#125;</code></p></li><li><p>利用<code>reduce + includes</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function unique(arr)&#123;</span><br><span class="line">    return arr.reduce((prev,cur) =&gt; prev.includes(cur) ? prev : [...prev,cur],[]);</span><br><span class="line">&#125;</span><br><span class="line">var arr = [1, &#x27;1&#x27;, 1, &#x27;1&#x27;, NaN, &#x27;NaN&#x27;, NaN, &#123;a: 1&#125;, &#x27;&#123;a: 1&#125;&#x27;, &#123;a: 1&#125;, undefined, undefined,  null, null, &#x27;undefined&#x27;, &#x27;null&#x27;, &#x27;undefined&#x27;, &#x27;null&#x27;];</span><br><span class="line">//[1, &#x27;1&#x27;, NaN, &#x27;NaN&#x27;, &#123;a: 1&#125;, &#x27;&#123;a: 1&#125;&#x27;, &#123;a: 1&#125;, undefined, null, &#x27;undefined&#x27;, &#x27;null&#x27;]</span><br></pre></td></tr></table></figure><p>没有去除<code>&#123;a: 1&#125;</code></p></li><li><p>利用<code>hasOwnProperty</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function unique(arr)&#123;</span><br><span class="line">    var obj = &#123;&#125;;</span><br><span class="line">    return arr.filter(item =&gt; obj.hasOwnProperty(typeof item + item) ? false : obj[typeof item + item] = true);</span><br><span class="line">&#125;</span><br><span class="line">var arr = [1, &#x27;1&#x27;, 1, &#x27;1&#x27;, NaN, &#x27;NaN&#x27;, NaN, &#123;a: 1&#125;, &#x27;&#123;a: 1&#125;&#x27;, &#123;a: 1&#125;, undefined, undefined,  null, null, &#x27;undefined&#x27;, &#x27;null&#x27;, &#x27;undefined&#x27;, &#x27;null&#x27;];</span><br><span class="line">//[1, &#x27;1&#x27;, NaN, &#x27;NaN&#x27;, &#123;a: 1&#125;, &#x27;&#123;a: 1&#125;&#x27;, &#123;a: 1&#125;, undefined, null, &#x27;undefined&#x27;, &#x27;null&#x27;]</span><br></pre></td></tr></table></figure><p>完美解决。</p></li></ol><H3> 求该数组[1, 0, 3445, 87, 1209, 4, 7, 9]可形成的最大整数 </H3><ul><li>将数组中所有数字转为字符串，按照首字母大小进行整体排序。</li><li>如果首字母相同，就通过while循环向后比较。</li><li>如果相比较的两个字符串长度不一样，先被循环完的字符串将始终用最后一位字母进行后续比较，比如1209和1进行比较时，前一位相同，1209的2就和1中的最后一位1进行比较，以此类推。完整示例如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function toInt(arr) &#123;</span><br><span class="line">    let newArr=arr.sort((a,b)=&gt;&#123;</span><br><span class="line">        a =&quot;&quot;+a;</span><br><span class="line">        b = &quot;&quot;+b;</span><br><span class="line">        let aLen=a.length;</span><br><span class="line">        let bLen=b.length;</span><br><span class="line">        let aIndex=0;</span><br><span class="line">        let bIndex=0;</span><br><span class="line"></span><br><span class="line">        while (aIndex&lt;aLen &amp;&amp; bIndex&lt;bLen)&#123;</span><br><span class="line">            let flag=false;</span><br><span class="line">            if (a[aIndex]==b[bIndex])&#123;</span><br><span class="line">                aIndex+1&lt;aLen &amp;&amp; (aIndex++,flag=true);</span><br><span class="line">                bIndex+1&lt;bLen &amp;&amp; (bIndex++,flag=true);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!flag)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (a[aIndex]&gt;b[bIndex])&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return newArr.join(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">const array = [1, 0, 3445, 87, 1209, 4, 7, 9]; </span><br><span class="line">const intNum=toInt(array);</span><br><span class="line">//987743445120910</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端面试题 </category>
          
          <category> Js篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 前端面试题 </tag>
            
            <tag> 前端 </tag>
            
            <tag> 前端基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
