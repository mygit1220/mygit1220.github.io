<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>路(三)</title>
      <link href="/mygit1220.github.io/2021/07/28/%E8%B7%AF-%E4%B8%89/"/>
      <url>/mygit1220.github.io/2021/07/28/%E8%B7%AF-%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<p>哥哥走后，弟弟便承担起了照顾两个家庭的责任，随着年岁增加，弟弟也到了议亲的年纪，两家的父母希望弟弟跟哥哥的亲生妹妹结秦晋之好，这样两家就顺理成章可以成为真正意义上的一家人了，弟弟自然不会反对，他从小就擅于照顾妹妹，妹妹自然是父母之命，媒妁之言。这样就在弟弟18岁的时候，两家结亲了，宴请了村子里的所有人，说是宴请倒也不如说是全村人一起出物出力帮他们办了这场酒筵。婚后两家的矮墙也彻底清除了，年轻夫妇日出而作，日落而息，倒也过着琴瑟和鸣的日子，长辈们也和和气气，一家人其乐融融，唯一的缺憾就是哥哥不在，也不知道在外面过的怎么样。夏季雨水本来就多，这天雨一直没听过，自然也不能出门干活，夫妻俩在家闲聊，自然也聊到了哥哥，妻子说她以为当初丈夫会跟着哥哥一起出门呢，后来听说丈夫不会去的时候，好生开心，顺道就问了丈夫当初为什么没离开。丈夫边编着箩筐边说道他当初进学堂学习的时候，听先生讲多了官场的事迹，本身就不喜欢当官，其次对先生教的东西没信心，也对自己没信心能干出一番事业，再者总要有个人要照顾家里的，既然哥哥打定主意要出去闯荡，那自己就留在家里也未尝不可。听罢丈夫的一番话，妻子更是对丈夫心生怜爱，从来不知道丈夫有这么多心事没说，心里暗想以后一定要多跟丈夫聊天，对他更好一些。转眼已经成亲两年了，日子也就这样平平淡淡地过着，没有一丝波澜，唯一的波澜便是已经成亲两年了，但是也不见妻子的肚子有动静，这不免让婆婆有些许微言，但是每次丈夫都能圆回去，也就罢了。</p><p>在京城的哥哥自然是不知道家里发生的事情，也不知道弟弟已经成亲了，离开饭庄的这两年在街上摆过摊替人写过书信，依旧参加了各种考试，但是一种从心底油然而生的无力感也使得他渐渐意识到自己的目标终究是黄粱一梦，每天靠着干点零活糊口，每逢过节的时候更是加深了他回家的念头，但是想到自己这几年一事无成，自尊心作祟，回家的念头也就打消了。这些年不是没有喜欢的姑娘，但是即便对方是普通人家的女孩，人家父母也看不上一个孤身一人的穷小子，只得作罢。就在他混沌度日的时候，传来一个消息，说是京城里有一家员外郎娶了多房小妾，依旧没有生出儿子来，膝下只有3个女儿，如今员外郎年纪大了，也不指望能生出儿子来了，只想着招上门女婿，待他日生下儿子继承家业，招上门女婿的条件倒也不苛刻，只需生的俊秀（基因要好），孤身一人（方便控制），能识文断字（要跟小姐有的聊），当然最重要的是跟自己女儿的八字要和，也不克老丈人。在哥哥的认知里，读书人是断断不能入赘的，有辱斯文，但是连续的挫折、目前的穷困生活以及对那个梦莫名的相信以及执着，让他动了入赘的念头，在良久的心理建设之后，哥哥决定去试试。</p><p>既已决定去试试，哥哥便去了员外府，一番简单的盘查之后，就让哥哥写了八字留下，回家等待合八字的结果。走出员外府的时候哥哥心里慌张了起来，因为刚才员外盘查哥哥的家世时，哥哥说谎了，他说他本是读书人家的孩子，但是家里招了灾，饿死了一家老小，只有他活了下来，哥哥说谎的理由很简单，就是想着能早点入赘员外家。但毕竟是第一次说谎，多少有点紧张，但事到如今已经没有退路了，只能硬着头皮扛下去。没过几天便传来了消息，说是可以入赘了，他什么都不用管，只需过去员外府等着拜堂成亲。顺理成章地哥哥成亲了，所幸的是，员外千金是真正的闺阁小姐，知书达理，倒也算是一桩不错的姻缘，日子也这样过了下去，除了平时要看别人的白眼，日子倒也平顺，很快小姐怀孕了，怀胎十月生下了一个大胖小子，员外高兴坏了，开棚施粥、寺庙布施样样少不了，员外对哥哥也是越看越顺眼。哥哥在员外府的日子过的不错，自然又是想起了家里，因为之前说家里都没人了，也对家人愈发的愧疚，再加上现在手里有了点钱，就更想回家看看了。他不知道的是村里也发生了变化，新上任的知府无意间知道了幸福村山里有丰富的矿产，便上报朝廷要给幸福村修桥，一方面是方便矿产出山，另一方面也是利民的好事，朝廷自然是拨款同意，就这样幸福村的桥就修了起来，整整修了两年，一条不算宽阔的桥修了起来，幸福村的人民也因为意外发现的矿产富裕了许多。这时候家里人想起了已经离家6年的哥哥，思念这种东西，一起唤起便无法抑制，尤其是老人，弟弟便决定自己去京城找哥哥，找得到最好，找不到的话便回来骗父母说哥哥过的很好，不必太过思念。不日，弟弟便动身出发去找哥哥了，弟弟是坐马车去的京城，用的时间自然是比哥哥要短，赶在七夕前弟弟便到了京城，京城的繁华自然也晃了弟弟的眼睛，但麻烦的是偌大个京城怎么找哥哥呢，毫无头绪，只能先住下来打听打听，弟弟便先住在了客栈，客栈伙计跟弟弟说明天是七夕节，傍晚会有放花灯活动，人肯定是找不到了，因为到处是人，但是可以看看京城的花灯活动也不为一件乐事。听罢伙计的话，弟弟更沮丧了，但也没办法，只能走一步看一步。</p><p>次日，街上果真人山人海，热闹非凡，弟弟在街上闲逛，边走边思考该如何找哥哥，走着走着边走到员外府门外，好巧不巧，他看到了一个人，虽然跟以前不一样了，但是赫然就是哥哥呀。他开心地叫着小时候叫哥哥的昵称，哥哥听到后也高兴坏了，他忘记了他周围的员外、妻子以及刚满一岁的儿子，冲向了弟弟，兄弟俩激动地拥抱着，述说这彼此的想念。他完全没有注意到员外阴沉的脸以及妻子担忧的神情，等他回过神来的时候，才意识到自己有大麻烦了。他决定坦白，他以为他都有孩子了，员外会看在孩子的面子上原谅他，接受他，以后自己也可以堂堂正正地去见家里人了。但是现实中没有那么多我以为、他以为、你以为，只有手握权利的人的以为，结局自然便是员外不能接受哥哥的欺骗、也不能接受哥哥的家人、更重要的是已经有儿子了，不再需要一个欺骗了自己的人，任凭自己女儿怎么哀求，员外还是坚持要把哥哥赶走。弟弟看到哥哥如今的处境便明白了哥哥这些年的苦楚，同时自己的到来又给哥哥惹了这么多的麻烦，更是心疼哥哥。员外是不可能接受哥哥了，当初成亲的时候哥哥可是签了契约的，如今这个局势，哥哥只能离开员外府了，只是可惜了孩子及妻子。哥哥虽然想到了可能会有这么一天，只是没想到事到临头了才发现原来还是这么难过。看到哥哥这个样子，弟弟便决定带哥哥回家，哥哥也经过了这么多事情后发现原来诺大个京城一直没有他的立身之地，心灰意冷之下跟着弟弟回家了，终究也没感受到张灯结彩，人声鼎沸的花灯节。</p><p>回家的路上弟弟陆续跟哥哥说了这些年家里的变化，以及他成亲了、村里修桥了之类的事情。听到这些哥哥虽然看着是开心的，但是弟弟明显能感受到哥哥的落寞，哥哥已经不是从前那个积极、乐观、傲气的哥哥了。终于在入秋的时候，弟弟带着哥哥回家了，虽然听弟弟讲了修桥的事情，但真正看到桥的时候，才豁然发现自己真的回来了，回到了梦里想了无数次的家，一路回家之后，自然是哭声一片，但这是喜悦的哭泣，是思念的倾诉，也是团圆的号角。哥哥在外面的事情自然是不能告诉家里人的，在幸福村里只有天知地知兄弟俩知。但是家人们也明显能感受到哥哥的变化，感觉清冷了很多，不像是以前那个话多的哥哥了，自然也就知道了哥哥这些年在外面没少吃苦，又是一阵心疼。在家待了几天后，哥哥的心情开阔了许多，也想明白了一些事情，不再执着于成就、功名这些虚渺的东西，想到以前装牛角尖的自己便觉得傻的可以，同时也觉得自己把书读迂腐了，便重新修建了学堂，立志这辈子要好好教书育人，真正意义上的教书育人，家里人自然是开心的。只是令家里人发愁的是哥哥立志一辈子不娶，而弟弟呢成亲这么年了一直没有所出，难道是要让他们绝后吗，殊不知不孝有三，无后为大，所以家里人便一直张罗着给儿媳妇吃各种补药，希望能有一儿半女。。。。。。</p><p>注：取名为路的原因如下：一、是因为幸福村没路所以哥哥更向往外面的世界，才引出了下面的故事；二、路也揭示着哥哥和弟弟选择的不同的人生之路</p><p>本文完！</p>]]></content>
      
      
      <categories>
          
          <category> 故事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 故事 </tag>
            
            <tag> 小说 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路(二)</title>
      <link href="/mygit1220.github.io/2021/07/28/%E8%B7%AF-%E4%BA%8C/"/>
      <url>/mygit1220.github.io/2021/07/28/%E8%B7%AF-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p>哥哥顺利地进城了，一进京城，他就被京城的繁华震惊了，走在大街上他觉得京城里的人也更漂亮，建筑也更好看，一切一切都那么美好，就这样走了好久，直到肚子咕咕叫的时候，他才意识到没钱吃东西，要想办法解决吃饭以及睡觉的问题。他突然就想到了那个梦，他人生地不熟也不知道去哪里找将军府邸，但书里写过，但凡是富贵人家必定是高门大户，那就一户一户地去看看吧，总会找到的，他这么安慰自己的时候，感觉肚子倒也不是那么饿了，这强大的信念呵！就这样找来找去，太快黑的时候终于让他找到了一个显赫的府邸，但不是将军府，门厅上赫然写着三个大字“公主府”，但是堂堂公主府岂是那么容易进的，结局可想而知，哥哥在街角蹲了一晚上，秋天的夜晚虽然不算太冷，但是又饿又冷毕竟还是难捱，但总算是天亮了，又是充满希望的一天。</p><p>次日，哥哥意识到这样不行，还没找到将军府呢就会被饿死，首先要先找一个落脚的地方，先要有饭吃，怀着这样的心情，哥哥踏上了找工作的路程。想到自己的一肚子学问，哥哥的首选工作是府衙文书，但是文书是要正式考取的，现在已经过了考试时间，要等明年才可以。其次是学堂先生，但是京城里的学堂先生也不是随便什么人都可以当的。最后为了糊口，哥哥不得不去了一家饭庄打杂，好在饭庄老板看哥哥不像是什么不好相处的人，而且又是一个饥肠辘辘的外乡人，方便少给工钱，几番周折之后，哥哥终于吃上了热呼呼的饭，心里也不免好生感概了一番。</p><p>就这样算是在这里安定了下来，虽然一天下来累的要死，但是好在有口饭吃，有地方睡觉，也算是一个进步。日子这样过着，虽然刚开始不习惯饭庄的生活，但是一个月下来，除了累，倒也习惯了，看着领到手的工钱，哥哥觉得自己来京城的目的跟现在的生活相差甚远，再想起家里的弟弟和亲人，不免更加忧虑急躁起来，想着干满3个月，一定要换一个离目标近的工作。所以接下来的日子，哥哥一边在酒庄干活，一边打听哪里需要幕僚，在酒庄干活的好处就是可以接触到各形各色的人，打听起消息来也更加方便，经过多方打听，终于等来了一个机会，说是真有一个新贵将军入驻京城，将军府招募文书，最重要一条是家底干净，写的一手好文章，哥哥喜出望外，这无疑是最近听来的最好的一条消息了，暗暗发誓一定要拿下，这样的机会可不是每天都有。次日，他便偷偷溜出去到了将军府报名考试，原来已经有很多人在排队了，经过简单的填表信息之后，就直接进入了考试环节，首先是考察文笔，以“论做官之道”为题作一篇文章，哥哥心花怒放，这个为官之道，先生交了好多遍，自然是笔到文来，心里好生得意了一番。接下来是一个简单的问答考试，考察的是实际应变能力。考完之后就让大家回去了，说是3天后会通知大家结果，哥哥自问答的不错，高高兴兴地会饭庄去了，虽然回去的时候被饭庄老板责骂了一顿，但想到美好的未来自也没说什么，麻利地干活去了。转眼3天过去了，等了一天也没等到人来通知他，再次偷偷溜去了将军府，一问才知道录用名单上没有他，调了卷宗给他看，上面的判词写道：年资甚浅、书生意气、不录。看罢心情一落千丈，再想到离家已近一年，还是一个打杂的，前路甚是渺茫，就更难过了，垂头丧气地回到了饭庄，又是一顿责骂。</p><p>转眼两年过去了，两年来哥哥一直在饭庄干活，期间也去试了各种招考，但每次都没过，现在相较两年前刚来京城的时候，气性已经被磨了不少。18岁的大小伙了，也不能一直在饭庄打杂，但是又找不到适合自己做的事情，两年了挣的钱也不多，深夜的时候一个人就会想家里人，甚至后悔当初莽撞出来了，外面的世界虽然精彩但是也很无奈。可是终究也还是心存希望，觉得还可以再等等，说不定再等等，就可以了，抱着这样的心态，倒也可以安心入睡了。好景不长，饭庄由于不景气，已经用不了这么多人了，老板要遣散人员，哥哥在名单之中。这一下，哥哥又开始了流浪的日子。。。</p><p>未完待续。。。。。。</p>]]></content>
      
      
      <categories>
          
          <category> 故事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 故事 </tag>
            
            <tag> 小说 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路(一)</title>
      <link href="/mygit1220.github.io/2021/07/28/%E8%B7%AF-%E4%B8%80/"/>
      <url>/mygit1220.github.io/2021/07/28/%E8%B7%AF-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>很久很久以前，在大山深处有一个叫幸福村的小村子，由于出入村子的通道只有一条索道，只有需要买卖东西的时候，村里的年轻人才会出去，所以村子里的人很少与外人接触，倒也过的自由自在，民风也甚是淳朴。</p><p>村里有一个读书人，年轻的时候，一心想着入仕上报国家，下效人民。苦读多年后终于成为了一名幕僚，怎奈读书人性格难以融入幕僚生活，心灰意冷亦或是认清现实后，回村子里成为了一名教书先生，一方面是以此糊口，再者也是希望能培养一个完成他理想的人。村子里的学堂不大，学生只有7、8个，故事就是从这两个学生展开的。</p><p>学堂里的学生本身就不多，其中有两个男孩子的年龄偏大，约莫十岁左右，偏巧他们两家是邻居，所以经常一起上下学、一起干活，亲如兄弟。他们两家仅隔了一堵矮墙，一探头就可以看到彼此的院子，两家的日子过的紧巴巴的，但是只要一方猎到野味，都会叫对方一起吃饭。每逢遇集的时候，那是最开心的了，这个时候兄弟二人会跟着村里的人爬索道去外面把家里编织的箩筐、猎物的皮毛换成钱或者生活用品，他们虽然羡慕着镇子里的繁荣，但却更加坚信十年寒窗苦读定会让他们走出大山，见识比镇子更大的世界，走在镇子上的两人倒也更坦然了，放佛他们已经见到了更宽广的世界，这大概就是信念的力量吧。村子里的日子日复一日，倒也没有多大的变化，唯一变化的可能就是变化本身了，当然兄弟俩也在圣贤书的熏陶下，愈发的有礼谦逊。出生月份大一点的哥哥从小性格就比弟弟要活跃一些，爱表现自己一些，弟弟则比较沉默安静，这么多年性格都也没变。前一年冬天的时候，教书先生受了风寒病倒了，一直也不见好，开春的时候，眼看着气色有点好转，结果清明的时候就不行了，在告诫了兄弟二人读书人的使命与气节之后就永远地闭上了眼睛。教书先生去世之后，自然也没有了学堂，入夏的一天，兄弟二人躺在院子里的草垛上看着天上的繁星聊天，聊对未来的想法。不知道是没有想法还是不想说自己的想法，弟弟一直也没有表达自己想法，说是聊天，但其实只有哥哥在说，哥哥说他一直想去村子外面的世界看看，人活一辈子不能把自己困在这小小的四方天地，那也就枉费了他读这么多年的圣贤书了，既然现在先生不在了，那可能就是上天给他的一个信号，他过两天就要离开村子去外面闯荡了。问弟弟愿不愿意跟他一起走，弟弟说要考虑考虑，哥哥这个时候已经明白了弟弟应该是不愿意随他一起离开。</p><p>到了约定的时间，弟弟送哥哥去了索道旁，哥哥就独自离开了村子，嘱托弟弟帮忙照顾自己的父母家人，弟弟依旧简短地说了让哥哥放心之类的话。哥哥跟弟弟说等他有了功名，第一件事就是帮村里修路，修一条让男女老少都可以走出村子的路，哥哥说相信他，一定不会很久的，说完哥哥就溜着索道走了，弟弟在索道旁站了好久，直到看不到哥哥的身影才缓缓离开。哥哥走出村子到了镇子里，全身上下只有一个小包袱和家里攒的一小串铜板，哥哥知道自己要去的路还长，就加快了前进的步伐，依靠着心里的信念以及路上人的帮助，走了数月之后，哥哥终于身无分文到了京城。赶到京城的时候天已经黑了，城门已经关了，想要省点钱的外乡人都会聚集在离城门不远的破庙里度过一晚，当然有钱的人自然是会去住店，哥哥也去了破庙，在破庙了他做了一个梦，梦里他一到京城就当上了将军府的幕僚，在将军府混的风生水起，迎娶了一个千金小姐，还入朝见到了皇上，官拜一品，随即他就下令给村子里修了一条路，那是多么宽敞的一条路啊，可是为什么看不到家人呢，为什么看不到弟弟了呢，瞬间他就惊醒了，才发现天蒙蒙亮了，原来是做了一场梦，他理了理思绪，觉得这个梦也许是老天爷给他的一个信号，他一定能干出一番事业来，想到这里，难以抑制的兴奋也使他没法入睡了，索性就起来朝城门走去。。。。。。</p><p>未完待续。。。。。。</p>]]></content>
      
      
      <categories>
          
          <category> 故事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 故事 </tag>
            
            <tag> 小说 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试题--JS篇(一)</title>
      <link href="/mygit1220.github.io/2021/07/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-Js%E7%AF%87-%E4%B8%80/"/>
      <url>/mygit1220.github.io/2021/07/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-Js%E7%AF%87-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<H3> 变量类型的判断 </H3><p>JS中常见的数据类型分为基本类型：<code>string、boolean、number、undefined、null、symbol(ES6)</code>和引用类型：<code>Object</code></p><ol><li><p>判断js数据类型最常用的是<code>typeof</code>，使用它会返回一个字符串，适合函数对象（function）和基本类型（js中的基本类型：<code>number、string、boolean、null、undefined、symbol、object</code>［对象］）的判断，例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(typeof 1);</span><br><span class="line">console.log(typeof &quot;str&quot;);</span><br><span class="line">console.log(typeof false);</span><br><span class="line">console.log(typeof null);</span><br><span class="line">console.log(typeof undefined);</span><br><span class="line">console.log(typeof function()&#123;&#125;);</span><br><span class="line">console.log(typeof new Object());</span><br><span class="line">console.log(typeof new Array());</span><br><span class="line">console.log(typeof [1,2,3]);</span><br><span class="line">console.log(typeof Symbol());</span><br></pre></td></tr></table></figure><p>结果为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">number</span><br><span class="line">string</span><br><span class="line">boolean</span><br><span class="line">object</span><br><span class="line">undefined</span><br><span class="line">function</span><br><span class="line">object</span><br><span class="line">object</span><br><span class="line">object</span><br><span class="line">symbol</span><br></pre></td></tr></table></figure><p>那么问题来了，如果想要判断一个对象是不是数组，使用<code>typeof</code>就会返回一个<code>object</code>，这时候就要使用<code>instanceof</code>来判断对象类型了</p></li><li><p><code>instanceof</code>操作符<br><code>obj instanceof Object</code>，左边操作数<code>obj</code>为对象（如果不小心写成基本类型 比如数字啥的，就会返回<code>false</code>），右边操作数<code>Object为</code>函数对象或者是函数构造器，否则抛出<code>TypeError</code>。<br>实质就是：<code>instanceof</code>操作符判断左操作数对象的原型链上是否有右边这个构造函数的<code>prototype</code>属性，也就是说指定对象是否是某个构造函数的实例，最后返回布尔值，这个对整个原型链上的对象都是有效的，由于<code>instanceof</code>对整个原型链上的对象都有效，因此同一个实例对象，可能会对多个构造函数都返回<code>true</code>！</p></li><li><p><code>Object.prototype.toString</code>方法<br>直接上例子，如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(Object.prototype.toString.call([]));</span><br><span class="line">console.log(Object.prototype.toString.call(&#123;&#125;));</span><br><span class="line">console.log(Object.prototype.toString.call(1));</span><br><span class="line">console.log(Object.prototype.toString.call(false));</span><br><span class="line">console.log(Object.prototype.toString.call(Symbol()));</span><br><span class="line">console.log(Object.prototype.toString.call(&#x27;str&#x27;));</span><br><span class="line">console.log(Object.prototype.toString.call(null));</span><br><span class="line">console.log(Object.prototype.toString.call(undefined));</span><br><span class="line">console.log(Object.prototype.toString.call(function()&#123;&#125;));</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[object Array]</span><br><span class="line">[object Object]</span><br><span class="line">[object Number]</span><br><span class="line">[object Boolean]</span><br><span class="line">[object Symbol]</span><br><span class="line">[object String]</span><br><span class="line">[object Null]</span><br><span class="line">[object Undefined]</span><br><span class="line">[object Function]</span><br></pre></td></tr></table></figure></li></ol><p>综上，判断的方法还有多种，但是有这三种也就够了，第三种胜在通用，但是拼写麻烦，也可以考虑第一种和第二种配合使用，这里提供一个完整的函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getType(data) &#123;</span><br><span class="line">    let type = typeof data;</span><br><span class="line">    if (type !== &#x27;object&#x27;) &#123;</span><br><span class="line">        return type</span><br><span class="line">    &#125;</span><br><span class="line">    return Object.prototype.toString.call(data).replace(/^\[object (\S+)\]$/, &#x27;$1&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(getType(() =&gt; &#123;&#125;)); //function</span><br></pre></td></tr></table></figure><H3> 前端去重的方法 </H3><ol><li><p>利用<code>ES6 Set</code>去重（ES6中最常用）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function unique (arr) &#123;</span><br><span class="line">    //Set数据结构，它类似于数组，其成员的值都是唯一的</span><br><span class="line">    return Array.from(new Set(arr)); // 利用Array.from将Set结构转换成数组</span><br><span class="line">&#125;</span><br><span class="line">var arr = [1, &#x27;1&#x27;, 1, &#x27;1&#x27;, NaN, &#x27;NaN&#x27;, NaN, &#123;a: 1&#125;, &#x27;&#123;a: 1&#125;&#x27;, &#123;a: 1&#125;, undefined, undefined,  null, null, &#x27;undefined&#x27;, &#x27;null&#x27;, &#x27;undefined&#x27;, &#x27;null&#x27;];</span><br><span class="line">//[1, &#x27;1&#x27;, NaN, &#x27;NaN&#x27;, &#123;a: 1&#125;, &#x27;&#123;a: 1&#125;&#x27;, &#123;a: 1&#125;, undefined, null, &#x27;undefined&#x27;, &#x27;null&#x27;]</span><br></pre></td></tr></table></figure><p>不考虑兼容性，这种去重的方法代码最少，但是无法去掉<code>&quot;&#123;a: 1&#125;&quot;</code>对象</p></li><li><p>利用<code>for</code>嵌套<code>for</code>，然后<code>splice</code>去重（ES5中最常用）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function unique(arr)&#123;            </span><br><span class="line">    for(var i=0; i&lt;arr.length; i++)&#123;</span><br><span class="line">        for(var j=i+1; j&lt;arr.length; j++)&#123;</span><br><span class="line">            if(arr[i]===arr[j])&#123;         //第一个等同于第二个，splice方法删除第二个</span><br><span class="line">                arr.splice(j,1);</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">return arr;</span><br><span class="line">&#125;</span><br><span class="line">var arr = [1, &#x27;1&#x27;, 1, &#x27;1&#x27;, NaN, &#x27;NaN&#x27;, NaN, &#123;a: 1&#125;, &#x27;&#123;a: 1&#125;&#x27;, &#123;a: 1&#125;, undefined, undefined,  null, null, &#x27;undefined&#x27;, &#x27;null&#x27;, &#x27;undefined&#x27;, &#x27;null&#x27;];</span><br><span class="line">//[1, &#x27;1&#x27;, NaN, &#x27;NaN&#x27;, NaN, &#123;a: 1&#125;, &#x27;&#123;a: 1&#125;&#x27;, &#123;a: 1&#125;, undefined, null, &#x27;undefined&#x27;, &#x27;null&#x27;]</span><br></pre></td></tr></table></figure><p>无法去除<code>NaN</code>和``{a: 1}<code>对象，因为</code>NaN === NaN和{a: 1} === {a: 1}` 不成立</p></li><li><p>利用<code>indexOf</code>去重 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    if (!Array.isArray(arr)) &#123;</span><br><span class="line">        console.log(&#x27;type error&#x27;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    var array = [];</span><br><span class="line">    for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (array.indexOf(arr[i]) === -1) &#123;</span><br><span class="line">           array.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br><span class="line">var arr = [1, &#x27;1&#x27;, 1, &#x27;1&#x27;, NaN, &#x27;NaN&#x27;, NaN, &#123;a: 1&#125;, &#x27;&#123;a: 1&#125;&#x27;, &#123;a: 1&#125;, undefined, undefined,  null, null, &#x27;undefined&#x27;, &#x27;null&#x27;, &#x27;undefined&#x27;, &#x27;null&#x27;];</span><br><span class="line">//[1, &#x27;1&#x27;, NaN, &#x27;NaN&#x27;, NaN, &#123;a: 1&#125;, &#x27;&#123;a: 1&#125;&#x27;, &#123;a: 1&#125;, undefined, null, &#x27;undefined&#x27;, &#x27;null&#x27;]</span><br></pre></td></tr></table></figure><p>无法去除<code>NaN</code>和<code>&#123;a: 1&#125;</code>对象</p></li><li><p>利用<code>includes</code>去重</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    if (!Array.isArray(arr)) &#123;</span><br><span class="line">        console.log(&#x27;type error&#x27;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    var array = [];</span><br><span class="line">    for (var i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (!array.includes(arr[i])) &#123;</span><br><span class="line">           array.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br><span class="line">var arr = [1, &#x27;1&#x27;, 1, &#x27;1&#x27;, NaN, &#x27;NaN&#x27;, NaN, &#123;a: 1&#125;, &#x27;&#123;a: 1&#125;&#x27;, &#123;a: 1&#125;, undefined, undefined,  null, null, &#x27;undefined&#x27;, &#x27;null&#x27;, &#x27;undefined&#x27;, &#x27;null&#x27;];</span><br><span class="line">//[1, &#x27;1&#x27;, NaN, &#x27;NaN&#x27;, &#123;a: 1&#125;, &#x27;&#123;a: 1&#125;&#x27;, &#123;a: 1&#125;, undefined, null, &#x27;undefined&#x27;, &#x27;null&#x27;]</span><br></pre></td></tr></table></figure><p>没有去除<code>&#123;a: 1&#125;</code></p></li><li><p>利用<code>reduce + includes</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function unique(arr)&#123;</span><br><span class="line">    return arr.reduce((prev,cur) =&gt; prev.includes(cur) ? prev : [...prev,cur],[]);</span><br><span class="line">&#125;</span><br><span class="line">var arr = [1, &#x27;1&#x27;, 1, &#x27;1&#x27;, NaN, &#x27;NaN&#x27;, NaN, &#123;a: 1&#125;, &#x27;&#123;a: 1&#125;&#x27;, &#123;a: 1&#125;, undefined, undefined,  null, null, &#x27;undefined&#x27;, &#x27;null&#x27;, &#x27;undefined&#x27;, &#x27;null&#x27;];</span><br><span class="line">//[1, &#x27;1&#x27;, NaN, &#x27;NaN&#x27;, &#123;a: 1&#125;, &#x27;&#123;a: 1&#125;&#x27;, &#123;a: 1&#125;, undefined, null, &#x27;undefined&#x27;, &#x27;null&#x27;]</span><br></pre></td></tr></table></figure><p>没有去除<code>&#123;a: 1&#125;</code></p></li><li><p>利用<code>hasOwnProperty</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function unique(arr)&#123;</span><br><span class="line">    var obj = &#123;&#125;;</span><br><span class="line">    return arr.filter(item =&gt; obj.hasOwnProperty(typeof item + item) ? false : obj[typeof item + item] = true);</span><br><span class="line">&#125;</span><br><span class="line">var arr = [1, &#x27;1&#x27;, 1, &#x27;1&#x27;, NaN, &#x27;NaN&#x27;, NaN, &#123;a: 1&#125;, &#x27;&#123;a: 1&#125;&#x27;, &#123;a: 1&#125;, undefined, undefined,  null, null, &#x27;undefined&#x27;, &#x27;null&#x27;, &#x27;undefined&#x27;, &#x27;null&#x27;];</span><br><span class="line">//[1, &#x27;1&#x27;, NaN, &#x27;NaN&#x27;, &#123;a: 1&#125;, &#x27;&#123;a: 1&#125;&#x27;, &#123;a: 1&#125;, undefined, null, &#x27;undefined&#x27;, &#x27;null&#x27;]</span><br></pre></td></tr></table></figure><p>完美解决。</p></li></ol><H3> 求该数组[1, 0, 3445, 87, 1209, 4, 7, 9]可形成的最大整数 </H3><ul><li>将数组中所有数字转为字符串，按照首字母大小进行整体排序。</li><li>如果首字母相同，就通过while循环向后比较。</li><li>如果相比较的两个字符串长度不一样，先被循环完的字符串将始终用最后一位字母进行后续比较，比如1209和1进行比较时，前一位相同，1209的2就和1中的最后一位1进行比较，以此类推。完整示例如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function toInt(arr) &#123;</span><br><span class="line">    let newArr=arr.sort((a,b)=&gt;&#123;</span><br><span class="line">        a =&quot;&quot;+a;</span><br><span class="line">        b = &quot;&quot;+b;</span><br><span class="line">        let aLen=a.length;</span><br><span class="line">        let bLen=b.length;</span><br><span class="line">        let aIndex=0;</span><br><span class="line">        let bIndex=0;</span><br><span class="line"></span><br><span class="line">        while (aIndex&lt;aLen &amp;&amp; bIndex&lt;bLen)&#123;</span><br><span class="line">            let flag=false;</span><br><span class="line">            if (a[aIndex]==b[bIndex])&#123;</span><br><span class="line">                aIndex+1&lt;aLen &amp;&amp; (aIndex++,flag=true);</span><br><span class="line">                bIndex+1&lt;bLen &amp;&amp; (bIndex++,flag=true);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!flag)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (a[aIndex]&gt;b[bIndex])&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return newArr.join(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">const array = [1, 0, 3445, 87, 1209, 4, 7, 9]; </span><br><span class="line">const intNum=toInt(array);</span><br><span class="line">//987743445120910</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Js </tag>
            
            <tag> 前端面试题 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
